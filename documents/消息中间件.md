1. 消息队列

消息队列是一种消息中间件，可以理解为是一种缓冲队列，生产者把消息发送到消息队列，消费者从消息队列取消息消费。

消息队列的三个特点，异步，解耦，削峰，具体解释略。

两种消费模式，点对点模式和发布订阅模式，点对点模式中一条消息只能被一个消费者消费。发布订阅模式允许一条消息被订阅主题的多个消费者消费。

kafka
主要设计结构就是 生产者->kafka集群->消费者
生产者生产的每条消息都有一个topic,主题可以理解为消息的种类。
一个kafka集群会有多个实例/服务器，每台服务器上可以设置多个主题。
每个topic下又有多个分区，设置分区的目的是为了提高吞吐量。这好比是多个水管流水的速度会比一个水管快。同时方便日后扩展(增加服务器，增加分区)。 
不同分区的数据并不保证是有序的，这其实取决于负载均衡的策略。但每个分区的数据内部有序，因为写入消息的时候总是从文件尾写入，所以kafka本身也不支持随机定位消息。 
同时，每个分区并不是只有一个，为了防止服务器宕机导致数据丢失，它会有多个备份，这些副本保存在多台主机上。所有副本之间有一个被称为leader，其它的都是follower。实际上生产者发送消息时只会push到leader，其它的follower主动去leader那里pull数据。消息者也只从leader那里pull消息。
最后，每个消费者都隶属于一个消费者组。一般情况下，一个消费者组只消费某个固定topic的消息。每个消费者可以消费多个分区李的消息，但是一个分区不能给多个消费者消费。你可以想象，多个水管可以放到一个盆里接水，但是你不能让多个盆去接一个水管里的水。



2. Redis

Redis有哪些数据结构
字符串String 字典Hash 列表List 集合Set 有序集合SortedSet

Redis设置过期时间需要注意什么
如果同一时间有大量的key过期，可能会产生卡顿，一般设置过期时间时会加上一个随机值，使得过期时间分散一些。所谓缓存雪崩就是指同一时间有大量key失效，导致查询全都落在数据库上。

缓存穿透
缓存穿透指攻击者不断请求不存在的key,这样在缓存中找不到时就会去数据库上查询，从而把数据库打垮。解决办法，当从数据库上查找一个不存在的key时，我们同时把它缓存，此时过期时间可以设置的短一点，比如五分钟。

Redis为什么使用单线程
因为cpu不会成为redis的瓶颈，redis的瓶颈是内存大小和网络带宽。单线程避免了繁琐的线程切换的问题，并且也不需要考虑各种锁。

Redis为什么快
完全基于内存操作。 数据结构简单。 不考虑线程切换。 多路IO复用模型。

Redis的应用场景
计数器(string)，如一个视频被观看的次数。
消息队列(list)。
排行榜(zset).

Redis过期策略
1.定期删除，没100ms随机抽取几十key，检查是否过期。如果过期的个数超过一定比例，继续执行删除策略。
2.惰性删除，访问key的时候会检查是否过期，如果过期不会返回任何东西。

Redis内存淘汰策略

持久化策略

