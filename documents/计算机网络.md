一. TCP三次握手

第一次握手:客户端向服务端发送一个不带额外数据的特殊报文段，该报文的SYN标志位会被置为1，同时会随机生成一个sequence number,我们假设它为x,x也一并发送给服务器。

第二次握手：服务端收到报文，确认SYN标志位是否为1，并在响应字段里添加一个ACK，值为x+1,同时自己也会随机生成一个SN，设它为y。

第三次握手：客户端响应ACK,值为y+1,SYN标志位置为1，这个报文段可以携带数据。

---

二. 为什么需要三次握手，不是二次，或者四次。

如果是两次握手，服务端会无法确认客户端是否收到了自己的SN。
这里SN其实就是数据传输过程中的序列号，用来标识出哪些数据包被收到了。
互联网上是不存在绝对可靠的通信协议的，三次握手已经能够完成数据传输前的所有初始化工作，四次握手就显得太多余了。

---

三. HTTP和HTTPS的区别

http是超文本传输协议，https是超文本传输安全协议，https协议比http协议多了一层ssl协议用于保证数据传输的安全性。ssl协议是位于传输层之上，应用层之下的中间层。ssl相当于在中间创建了一个套接字，把http要发送的数据加密后传递给tcp，同样也从tcp中取得数据解密后提交给http。要讨论https协议，就不得不讨论数据传输的加密方式了。

我们设通信的双方为A和B。

对称加密，A和B采用相同的密钥对数据进行加密，这样做的问题是，服务器给客户端传送密钥时可能会被第三方窃取。

非对称加密，服务端生成公钥和私钥，服务端先把公钥发送给客户端，客户端使用公钥加密数据，这样，只有公钥是暴露的，但是公钥是不能解密数据的，所以 只有持有私钥的服务端可以拿到数据的原文。但是这样做的问题是，在传递公钥的时候，如果被第三方截获并伪造一个公钥发送给客户端，客户端是没有办法识别的。

此时我们引入签发机构，这里会使用到数字签名的概念，可能会讲解的有些绕。 我们会生成一个文件，里面有要传递的公钥，签发者id等等信息，我们称它为P,对P哈希可以得到HP,再使用签发机构的私钥对HP加密，得到S。服务端会把P和S都发送给客户端（这个文件就称为数字签名），客户端使用签发机构的公钥解密S得到一个哈希值HS，并且使用同样的方法对P哈希得到$HP^{'}$,如果$HP^{'}$和HS不相同，说明P被篡改过，否则可以知道这是个有效的签名。 这里有一个很重要的点就是哈希是不可逆的，无法从哈希值推出原文。

---

四. TCP和UDP的特点和区别

TCP是面向连接的协议，使用TCP连接需要先进行三次握手，断开连接时需要进行四次挥手。UDP则是面向无连接的，只要双方创建套接字，并设置监听端口，就能随时进行发包。

TCP保证可靠的数据传输，它根据速率控制，重传控制，还有数据校验保证提供可靠的数据传输服务。而UDP只是保证尽力而为地传输数据，并不保证数据的可靠性。

TCP消耗的资源多，报文头部是20个字节，UDP只有8个字节。

UDP传送速率更快，因为TCP需要使用滑动窗口控制数据发送速率。

TCP是面向字节流的，UDP是面向报文段的，每一个报文就是一条完整的消息。

---

五. Post方法和Get方法

Post方法一般用于提交数据，比如提交密码到服务端，Get方法一般用于获取资源，比如请求一张图片。

相比Get,Post更安全，因为Get提交的参数都会出现在地址栏的url里，查看浏览记录就能轻松查看到。

Post能提交的数据量更大，因为浏览器会对url的长度做限制。一般来说，虽然服务器也会对请求长度作出限制。但即使这样，Post可以提交的参数长度还是要比Get长很多。

Get方法一般会被CDN缓存用以减少服务器负担。因为Get被认为是符合幂等性和安全性的，不会修改数据库的信息。

---

六. IP，子网掩码，网关

IP全名叫互联网协议地址，用来标识主机和网路寻址。目前所使用的版本为IPV4协议。用一个32位的二进制数来表示一个IP地址。为了便于管理，IP地址分为网络号和主机号。IP可分为五类，A,B,C,D,E,常用的是A,B,C。A类IP的第一个字节是网络号，后三个字节是主机号，但是网络号的第一位是网络标志位，必须是0，所以只有7位可用，且不可全为0和1，所以实际只有$2^{7}-2$个网络号，实际主机号为$2^{24}-2$个,全为0和1是保留地址，主机号全为1是该网段的广播地址。
B类IP前两个字节是网络号，网络标志位是10，实际可用网络号个数是$2^{14}$,实际主机号是$2^{16}-2个$。
C类IP前三个字节是网络号，网络标志位是110，实际可用网络号的个数是$2^{21}$,实际主机号是$2^{8}-2$个。
D类E类不分网络号和主机号，用于特殊使用。

子网掩码，同样是一个32位的二进制数，作用是标识IP地址的网络号和主机号，子网掩码的二进制是一段连续的1，然后加上一段连续的0，有多少个连续的1说明IP地址中有多少位是网络号，剩下的0都是主机号。
A类IP默认的子网掩码是255.0.0.0,B类IP默认的子网掩码是255.255.0.0,C类IP默认的子网掩码是255.255.255.0。

网关是当前主机的默认路由，一般是一台路由器。当两台主机不在同一个网段(网络号不同)时，它们无法直接通信，需要先把报文发送到网关，由网关转发。

---


七. 公有IP和私有IP

公有IP是由因特网信息中心分配给提出申请的组织机构，通过它可以直接访问因特网，是广域网范畴的。

如果是一个企业或者家庭内部组建局域网，一般都会使用私有IP。私有IP禁止出现在互联网上，如果企业内部的设备需要上网，则需要通过NAT穿透技术，把私有IP转换为公有IP。

----

八. 半连接队列

服务端在第一次收到客户端的SYN请求时，此时双方还未完全建立起连接，服务端会把此种请求放在一个队列里，我们把这个队列叫半连接队列。
完成三次握手后服务端把请求的连接放在全连接队列里。
服务端在发送SYN-ACK包后，如果未收到客户端的确认包，会进行重传，在linux系统下，重传的次数是5次，并且每次等待的时间是指数增长，一般是1s,2s,4s,8s,16s,最后一次是32s，所以总共的等待时间是63s。

---

九. SYN攻击

SYN攻击是基于TCP握手来实现的，攻击者在短时间内伪造大量不存在的IP地址，并向服务端发送SYN包，服务端则回复ACK信息，并等待客户端确认，由于源地址并不存在，服务端需要不断等待并重传。在等待第三次握手的时候，服务端需要分配资源。伪造的大量SYN包占用半连接队列，导致正常的SYN请求因为队列满而被抛弃，达到网络拥塞甚至系统瘫痪的后果。

---

十.滑动窗口机制

首先得知道什么是流量控制。通常我们在网络上发送数据时，肯定是希望速度越快越好。但是如果发送数据的速度过快时，接收方很有可能来不及处理导致接收缓存溢出，数据丢失等问题。所以发送方和接收方必须得有一套方案来决定发送速率，这个就是流量控制。而流量控制是通过滑动窗口来实现的。
接收端和发送端都会维护一个滑动窗口。假设接收端收到一个报文以后，发送一个确认报文给发送端。确认报文里会有两条信息，一条是ack，代表ack之前的字节已经全部收到，现在希望收到从ack开始的字节，另一条是rwnd，这个是滑动窗口大小，代表接收缓存大小是rwnd。发送方收到消息以后，会将滑动窗口的后沿移动到ack，并保持窗口大小是rwnd。 
tcp如何保证可靠的传输呢，ack确认机制就是一种做法，接收端采取累积确认的方式，告诉发送端已经收到的字节号，tcp协议规定一般收到报文0.5秒内进行确认。对于未按序到达的字节，tcp协议并未规定处理方案，最简单的方法是忽略它，但这样会导致大量数据重复发送，产生许多开销。所以一种更好的方案是把未按序到达的数据放在滑动窗口缓存中，等待所有数据到达后再交付上层应用进程。对于发送过程中丢失的数据，因为发送端没有收到确认，在等待时间超过确认计时器后，发送端会重新发送这部分数据。 
补充一点，在接收端收到0窗口大小的确认报文后，就不能再发送数据了，但此时每隔一断时间发送端会发送1字节的窗口大小探测报文给接收端，询问此时的窗口大小。
另外，由于tcp是一种全双工的通信方式，所以实际上在每一个端都有接收窗口和发送窗口。

---

十一.tcp粘包

粘包的原因是tcp是一个面向字节流的协议。 发送端为了提高带宽利用率，会把多个消息封装成一个大的数据块进行封包。这样接收端就出现了粘包现象，后一数据包的头紧贴上一个包的尾。
tcp默认使用Nagle算法，即合并或拆分多个消息，封装成大数据块发送。

处理办法，发送方可以关闭Nagle算法。接收方在应用层循环处理读取消息。 如何识别消息长度，格式化数据，在一条数据尾部添加结束符；发送时一并发送消息长度。

udp协议不会出现粘包，因为udp协议是面向报文的，接收方一次只会接收一条独立消息。

--- 

十二. Http状态码
1xxx: 服务器收到请求，等待客户机下一步操作。
2xxx: 服务器收到请求，并且成功处理。
3xxx: 发生重定向，等待客户机下一步操作来完成请求。
4xxx: 客户机发生错误，请求的语法不正确等。
5xxx: 服务器错误，无法处理客户机的请求。

---

十三. Http2.0新特性

---

十四. ARP协议
ARP协议全称地址解析协议，用来实现IP地址到MAC地址的转换。(IP可以理解为收件人姓名，MAC为收件人地址)
ARP协议属于网络层，但是基于功能来考虑说它是链路层协议好像也没什么问题
考虑网络中PC1要和PC2通信，PC1知道了PC2的IP，但实现通信需要知道PC2的MAC地址。PC1会先查询本地的ARP缓存表，如果发现没有。则向网络中发送一条广播信息。这条信息包括PC1自己的IP和MAC地址以及目标IP。当交换机收到广播时，会转发给同一局域网下的所有主机。如果不是PC2,不会答复广播。否则PC2缓存下PC1的IP和MAC，并把自己的MAC告诉PC1,此时就不需要广播了。

---

十五. 四次挥手
第一次，客户端发送请求断开的消息，FIN标志位为1，SN=x;
第二次，服务端确认收到断开请求，ack=x+1;
第三次，服务端发送请求断开的消息，FIN标志位为1，SN=y;
第四次，客户端确认收到断开请求，ack=y+1,在等待2MSL(最大报文生存时间)后，正式断开连接;

为什么最后一次挥手客户端会等待2MSL？
因为客户端无法确认第四次的消息是否被服务端接收，如果没有，客户端可以继续等待服务端的第三次挥手。

---

十六. cookie,sesssion,token
http协议是无状态的，我们需要使用一些技术来保存用户的请求状态。
cookie是保存在浏览器里，而session保存在服务器。客户端第一次请求时，服务端返回的数据里带有set-cookie字段，于是浏览器会创建一个cookie。以后的每次请求，浏览器都会在请求头里带上这个cookie,服务端收到cookie,会找到这个cookie对应的session,seesion存储了用户的所有信息。
理论上只使用cookie也可以保存状态，为什么还需要使用session? 为了安全，如果所有信息都保存在浏览器里，一旦被劫持就不妙了。同时，服务器保存信息可以让通信时开销小一点。

使用session会遇到负载均衡的问题，因为你的信息只保存在一台主机上，如果下一次你的请求被分发给其他主机，那它不会认你的cookie。解决方法是使用sticky session，或者负载均衡的策略使用hash分配的策略。

token和cookie很类似。都是服务器发给客户端的一个通行证。









