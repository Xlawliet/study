# 计算机网络

## 分层

- 应用层：数据单位为报文，HTTP，SMTP，FTP，DNS协议。
- 传输层：将上层数据进行端到端的数据传输，TCP，UDP协议。网关。
- 网络层：对数据包路由控制，网络拥塞控制，数据单位为IP数据报，IP，ICMP，ARP，RARP协议。路由器。
- 链路层：把电信号分组，封装为(以太网)帧，里面有标头和数据两部分；以太网协议。MAC地址（网卡上的标识地址，计算机之间传输数据通过MAC寻找）。
- 物理层：连接电脑，在电脑之间传输电信号。中继器，集线器。

## IP

IP地址，又叫互联网协议地址。有ipv4和ipv6两个版本。主要用于标识主机和寻址。

ipv4有ABCDE五类地址， ABC类是常用地址，D类地址作为组播地址（一对多的通信），E为保留地址。

**ipv4是用32位二进制数来标识**

- A类地址：前8位是网络号， 后24位是主机号。由于网络号还有个0是标志位，所以网络号只有七位可用，且不可全为0和全为1，所以A类地址的网络号只有$2^{7}-2$个。主机号全为0是保留地址，全为1是该网段的广播地址，所以可用的为$2^{24}-2$个。
- B类地址：前16位是网络号，后16位是主机号。网络号中有10是标志位，除去全0，全1，所以可用$2^{14}-2$个。主机号同A类情况，$2^{16}-2$个
- C类地址：前24位是网络号，后8位是主机号。网络号标志位110，可用$2^{21}-2$个。主机号可用$2^{8}-2$个

只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。

**子网掩码**

32位二进制数，为了标识ip地址的网络号和主机号，默认子网掩码网络号部分全为1，主机号部分全为0。如A类地址子网掩码为255.0.0.0，B类地址为255.255.0.0。

**网关**

网关是当前主机的默认路由，一般是路由器实现。当两个主机处于不同网段(网络号不同)，无法直接通信，需要由网关进行转发。

**公有IP**

是因特网信息中心分配给组织机构，通过它可以直接访问因特网，属于广域网。

**私有IP**

组织内，或者家庭组件的局域网IP。私有IP禁止出现在互联网中，要想通过互联网访问私有IP，需要内网穿透技术。

## ICMP

ICMP是网络控制报文协议(Internet Control Message Protocol, ICMP)。

ICMP是一种面向无连接的协议，用于传输出错报告控制信息。

它属于网络层协议，主要用于在主机与路由器之间传递控制信息，包括报告错误、交换受限控制和状态信息等。当遇到IP数据无法访问目标、IP路由器无法按当前的传输速率转发数据包等情况时，会自动发送ICMP消息。

## Ping的过程

PING （Packet Internet Groper），因特网包探索器，用于测试网络连接量的程序 。Ping是工作在 TCP/IP网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送 ICMP（Internet Control Message Protocol 因特网报文控制协议）Echo 请求报文，测试目的站是否可达及了解其有关状态

## ARP

**是根据IP地址获取物理地址的一个协议。**

ARP协议是“Address Resolution Protocol”（地址解析协议）的缩写。在以太网环境中，数据的传输所依懒的是MAC地址而非IP地址，而将已知IP地址转换为MAC地址的工作是由ARP协议来完成的。

## RARP

**逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址**

## NAT

NAT网络地址转换(Network Address Translation)属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术

## DHCP

DHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。

**客户端主机请求IP的过程**

一个主机想要上网需要四个条件：本机的IP地址，子网掩码，网关的IP地址，DNS的IP地址。

DHCP协议规定，每个子网中有一台主机负责管理本网络的所有IP地址，它叫做`DHCP服务器`。一台新的主机想要加入网络就必须向DHCP服务器请求IP和相关网络参数。

但是主机想要给另一台主机发送数据包需要知道对方的MAC地址和IP地址，但是此时新主机不知道这两个地址。

DCHP协议是基于UDP的。

- 以太网标头：设置发出方的MAC地址和接收方的MAC地址，后者此时不知道，就填入一个广播地址。
- IP标头：设置发出方的IP地址和接收方的IP地址。这两者此时都不知道，于是发出方IP地址设置为`0.0.0.0`，接收方地址设置为`255.255.255.255`。
- UDP标头：设置发送方和接收方端口，这是DHCP规定好的，发出方是68，接收方是67.

此时数据包就可以发出了，以广播的形式，其他计算机看到源和目的IP地址就知道这是发给DHCP服务器的数据包，就自动丢弃它。DHCP服务器看到这个数据包就知道是发给它的，于是它分配给客户主机一个IP地址，并发送DHCP响应包，这个也是类似的，只不过IP地址的发送方为DHCP服务器的IP地址，目标地址为`255.255.255.255`。客户主机收到这个数据包，就知道了自己的一些IP参数；

## HTTP

HTTP 是一种 `超文本传输协议(Hypertext Transfer Protocol)`，**HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范**。

HTTP是一种无状态协议，无状态是指对用户的操作没有记忆能力。

get和Post

get请求携带参数时放在请求路径不安全，且参数大小会有限制；而post数据在body里面，数据安全，没有大小限制。

get在请求时直接发送tcp包，收到200状态码结束。post会先发一个试探包，收到100状态码时会继续发送数据部分。
get会被浏览器主动缓存，post需要设置。

get在浏览器反复前进后退是无影响，post会反复提交表单数据等。

## HTTP1.0和1.1区别

1.0只提供了简单的认证，数据都是未加密的，不安全。并且每次请求都会建立tcp连接，结束后关闭连接。缓存控制只有expire和if modify since。不能断点续传。一个计算机只能有一个ip。

1.1有了摘要算法加密。变为了**长连接**，即每次请求结束后可以不断开tcp连接。**缓存控制**`cache-control`。支持断点续传`range`。一个计算机可以有多个虚拟主机，它们共享一个ip。

断点续传：在Http请求中多定义了一个断点续传相关的Http头 Range和 Content-Range，在下载文件的时候就会告诉服务端应该从何处继续传输。

2.0压缩请求头。**二进制分帧**。**强化安全**：运行在https上；

## HTTP2.0多路复用

1.0的时候，客户端需要等待服务器响应后再发下一个请求。

1.1提出了管线化理论（仅提出，默认是关闭的），客户端不需要等待响应，一下发送多个请求，但接受响应还是按顺序的。所以无论1.0还是1.1都会出现阻塞的情况，称为**线头阻塞**。

==1.1及以前是文本格式传输。2.0引入二进制数据帧和流==，（帧只是把1.1的报文header和body封装了一层）帧对数据进行顺序标识，浏览器接收后按照顺序对数据进行合并。HTTP连接上的每个帧都会标识属于哪个流。

TCP连接中承载了多个双向流通的流，它是由二进制帧组成的，由于二进制帧标识了数据顺序，所以每个响应可以分多次返回且不需要按顺序。

**通用标头：**Date，Cache-Control，Connection

**实体标头：**Content-Type，Content-Length，Content-Encoding

**请求标头：**Host，Accept-Charset，Accept-Encoding，Accept-Language，User-Agent

**响应标头：**Access-Control-Allow-Origin，Keep-Alive

## **地址栏输入url发生了什么**

首先会在浏览器缓存中查找是否有该url对应ip，如果没有就在系统的host文件中查找，如果还没有就发送到本地区ISP，ISP有本地DNS服务器，它会先查找是否有对应IP，如果没有就在网络中发起一个DNS查询，从根域名服务器开始，到顶级域名服务器，再到权威域名服务器，再返回ISP 本地DNS服务器，然后返回给客户端对应IP地址，客户端进行访问。

## Cookie

Cookie是服务器为了标识客户端身份而生成的一个键值对，里面一般存放用户相关信息，日期，过期时间，和sessionID。cookie在客户端请求的响应里面被存储到浏览器或者本地磁盘。后续访问网站时在请求时加上cookie，服务器就能通过里面的sessionid找对对应的session对象，从而确定客户端身份。

## Session 

HTTP是无状态协议，当数据传输后，服务器并不知道是哪个具体的用户。在用户发送请求时，服务器需标识用户，跟踪用户，所以需要为每一个用户创建一个session，用来保存用户的信息。session可以保存在内存，数据库或者专门的session服务器中。

用户第一次发送请求时，服务器为用户创建的一个存储用户信息的对象。每一个session会有唯一的标识Id。再响应的数据中会添加一个包含sessionId的cookie。下次判断用户session就需要cookie了。当客户端访问携带cookie时，服务器从里面通过sessionid获取对应session对象，确定用户身份。

session是服务器用于标识用户的一种机制，存放在服务器。cookie是保存用户信息的一种机制，存放在客户端，也是session实现的一个条件。

## Token

在服务器的session存储过多时可能造成服务器内存不足，若为集群服务器很可能会产生session的转移，或者频繁去查数据中的session。这些都非常消耗资源。由此token产生，Token是在客户端第一次登录时，验证成功后，服务器通过用户认证信息，和服务器的私钥通过加密算法进行加密生成数字签名，并和用户信息通过base64编码一起发过去（这里不会发送密码类信息）。当客户端收到token时，后续请求都携带上token，服务器再通过加密算法和私钥对用户数据进行计算，如果签名和传过来的签名相同，则认证成功，否则认证失败。

优点：无状态，可扩展，安全

## HTTPS

**HTTP与HTTPS区别**

默认端口不一样，HTTP是80，https是443.

url开头不一样。

HTTP数据无加密，不安全，https通过ssl实现了安全的数据传输。

**概述**

客户端会根据证书的域名，有效期，和本地的权威机构根证书验证是否合法。如果不合法浏览器会提示证书不安全。若合法，客户端会根据证书中公钥对数字签名进行验证，如果验证成功，客户端会产生一串随机数，并用公钥加密这个随机数，服务端会根据私钥解密这个随机数，然后通过这个随机数对传输的数据进行加密。

**为什么数据传输是对称加密**

非对称加密效率不高，在大量交互场景下不满足需求。

**证书一般包含的信息**

颁发机构信息，域名，公钥，有效期。

证书中还会有==证书中信息通过加密算法==生成的数字签名。

数字签名就是一种保证数据完整性（不被篡改）和有效性（是真正的使用者发来的，不是伪造者发来的）的手段。它一般是通过给数据生成的hash值通过加密生成。

**为什么要有签名**

因为证书机构是公开的，中间人也能申请，如果没有数字签名，中间人拦截请求后，把证书换为自己的证书，有自己的私钥，就可以截取客户端的真实数据了。如果有签名，若证书被换，签名也会被替换，通过签名可以验证对方的身份，验证失败就代表不是我们的访问目标，就提示不安全。

**为什么要CA证书**

证书就是对公钥合法性提供证明的技术。如果不存在认证机构的证书，则可以有中间人进行伪造证书，修改客户端与服务端传输的数据。

客户端向服务器发送请求被中间人拦截，中间人发送自己的证书和公钥给客户端，通过自己的私钥解密客户端的随机数。然后用客户端的请求数据发送给服务器，服务器返回证书和公钥，中间人发送自己的通过公钥加密的随机数给服务器，这样就能获取客户端需要的真实数据，然后对真实数据进行修改，再通过客户端的随机数进行加密，这样客户端得到的就是虚假的数据。所以不安全。

## TCP，UDP

UDP是用户数据报协议，它不需要连接，传输速度快，且能发送大量数据包。

TCP是传输控制协议，它需要握手挥手的连接，传输速度较慢。

UDP因为无连接，所以可以一对多进行发送，tcp需要连接，只能一对一进行数据发送。

udp不保证可靠性，tcp有超时重传，拥塞控制等保证可靠性。

udp数据包不按顺序，tcp是顺序发送。

udp会有错误校验，但它会丢失错误的包，tcp会进行校验和纠错。

## 滑动窗口

**流量控制**

通过网络传输数据，我们自然是希望速度越快越好，但是当速度过快时可能会造成数据的丢失，所以需要发送接收双方协商好，选择一套合适方案决定发送的速率，进行数据传输。流量控制就是通过滑动窗口实现的。

**滑动窗口**

发送端和接收端都会维护一个窗口。当接收端收到一个报文时，会返回发送端一个ACK，里面包含`ack:下一个需要接收的序列号（ack之前的已收到）`，`rwnd:接收缓存的窗口大小`，发送端会将发送端的窗口移动到ack位置，并设置窗口大小为`rwnd`。

对于未按序到达的数据，一般都存放在窗口缓存中，等所有数据都到达了，再交给上层应用。

对于发送中丢失的数据，发送端未收到ACK超时就会进行重发。

TCP是全双工的通信方式，每一端都会有发送窗口和接收窗口。

## TCP拥塞控制

发送方维护一个`cwnd`的变量，即为拥塞窗口的大小，其值由于网络拥塞的状况动态变化。只要网络出现拥塞，拥塞窗口就减少一些（判断依据，是否发生重传）

> `rwnd`接收窗口，接收端给的限制。
>
> `cwnd`拥塞窗口，发送端的限制。

发送方的当前发送窗口为`min(rwnd,cwnd)`，并设置一个阈值变量ssthresh，并设置初始值。

当拥塞窗口大小小于阈值，执行慢开始算法，大于执行拥塞避免算法。

> 传输轮次：发送窗口大小的数据包，并且收到了所有的应答。 

**慢开始算法**

在初始建立连接时，拥塞窗口大小为1，刚开始只能发送一个包，每个传输轮次后，窗口大小乘2，后面依次为4，8，16等。当达到阈值时，就执行拥塞避免算法。

**拥塞避免算法**

每个传输轮次后，拥塞窗口大小加一，继续发送。直到产生超时重传数据时，更新阈值为当前窗口大小的一半。窗口大小重置为1，继续开始慢开始算法。

**快速重传**

改进tcp性能的后续增加的算法。有时个别报文丢失不一定产生了拥塞，如果导致超时重传，重新慢开始降低了效率。

要求接收方在收到报文后立即发送应答，收到失序的报文要**发送已收到的报文号进行重复应答**。

发送方一旦收到三个重复的报文，就进行对应报文的重传，并且执行快速恢复算法。

> 快速重传的SACK机制
>
> 由于需要快速重传时不缺定时重传该ack的报文，还是ack及之前所有的报文。
>
> 所以通过在tcp报文中加一个sack字段，表示当前窗口已收到的范围，比如缺失`[200,299]`，但是已收到`[300,600]`，这时ack就返回`200`，而SACK为`[300,600]`

**快速恢复**

为了效率不执行慢开始算法，而执行快速恢复算法。把拥塞窗口和阈值置为当前窗口的一半，继续执行拥塞避免算法。

## 半连接队列

服务器会把所有未收到客户端ACK的SYN连接请求放入一个队列，这个队列一般叫做半连接队列。当收到对应ACK时。放入全连接队列。

服务端在第二次握手后，如果未收到客户端应答包，会进行重传，Linux默认为五次重传，间隔时间从1s，2s，4

s...32s，总共等待时间63s。

## SYN攻击

SYN攻击是通过TCP握手实现的，发送方通过伪造不存在的IP，发送大量SYN连接请求，服务器收到请求会将其放入半连接队列，由于等不到ACK，半连接队列满很快就会满，从而收不到正常的SYN请求，甚至造成网络拥塞，系统瘫痪。

**避免**

- 加大半连接队列的容量
- 减少SYN-ACK重试次数
- 增加SYNcookie，第一次接收到SYN时，服务器根据这个SYN计算出一个Cookie，发给客户端，客户端回复ack加上这个cookie，服务器验证cookie合法再分配连接资源。

## TCP快速打开

**第一次连接**

1. 客户端发送SYN请求。
2. 服务器通过这个SYN计算出一个cookie，放到tcp报文的`fast open`选项中。
3. 客户端把这个cookie缓存下来，后面正常三次握手。

**后续的连接**

1. 客户端发送SYN请求时把之前缓存的cookie以及HTTP请求发送给服务器。
2. 服务器验证cookie合法性，如果成功，就能直接给客户端进行HTTP响应。
3. 客户端的ack发送到服务器。

> 客户端最后握手的 ACK 不一定要等到服务端的 HTTP 响应到达才发送，两个过程没有任何关系。



## 一个包会无限在路由中转发吗

Ip数据包有一个8bit字段，里面存放的是TTL，是指数据包在被丢弃之前的允许通过的最大网段数量。每经过一个路由器转发，路由器就会把该字段的值减一，直到为零被丢弃。

# MySQL

MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一。

## 关系型与非关系型数据库

- 非关系型数据库优势

NoSQL是基于键值对的，不需要SQL解析，查询性能很高。

基于键值对，数据之间耦合度低，便于拓展。

- 关系型数据库优势

可以通过SQL进行复杂查询。

对于安全性要求高的可以实现。

## 存储引擎

数据库底层的软件组织，数据库管理系统对数据进行操作就需要通过执行引擎实现。不同的执行引擎在存储，索引，功能实现都有区别。

常见的几个存储引擎：MyISAM，InnoDB，Memory。

## **MyISAM和InnoDB区别**

MyISAM表和索引时分开的，有索引文件，表结构文件和数据文件，InnoDB数据文件和索引是一起的。

MyISAM不支持事务，InnoDB支持，并且有事务隔离级别并发度控制。

MyISAM存储表的总行数，InnoDB不存储。

MyISAM采用非聚簇索引，InnoDB主键采用聚簇索引，辅索引为非聚簇索引。

对查询效率要求较高可以使用MyISAM，一般使用InnoDB。

## 主键

**超键：**唯一标识一元组的==属性集合==，可以包含冗余属性，只要能唯一标识元组。

**候选键：**不含冗余属性，属性集合最小的超键。

**主键：**数据库表中唯一标识一组记录的列。可以多个列作为主键。

**外键：**一个表中包含了另一个表中的列。必须是另一个表的unique列。只要确保唯一索引。

## 范式

- 第一范式：(确保每列保持原子性)所有字段值都是不可分解的原子值。
- 第二范式：(确保表中的每列都和主键相关)在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。
- 第三范式：需要确保数据表中的**每一列数据都和主键直接相关**，而不能间接相关。
- BC范式：符合第三范式，**并且，主属性不依赖于主属性。**

## 为什么用自增列作为主键

如果列定义了主键，InnoDB会用主键作为聚簇索引。如果没有主键，会用表中唯一且没有空值的列作为索引，如果还没有，InnoDB会设置一个隐式的列作为聚簇索引。

数据被记录在聚簇索引（B+数）的叶子节点（内存页或者磁盘页）上，这就要求数据必须按主键顺序存放。如果主键是自增的顺序，那么每次插入就会顺序添加到当前索引的后续位置。如果不是自增的顺序，每次索引类似于随机，InnoDB需要找到适合主键顺序的中间索引位置，可能需要进行移动数据（甚至某些数据可能被持久到磁盘），再进行数据存放，这样频繁的移动需要大量的分页，而且得到了不紧凑的索引结构，而且可能需要optimize table，效率很低。

## 视图

是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。



## 什么是存储过程

一个预编译的SQL语句，可以模块化的设计。创建后可以调用多次。

**优点：**效率高，安全性好，复用性好

**缺点：**移植性差

**触发器：**一种特殊的存储过程，可以通过触发器阻止未经许可的操作。可以联级触发，如一个表的触发器包含了对其他表的操作，可以触发其他表的触发器。

## 关联子查询

这个查询为查找当前商品售价大于其所属种类的所有商品的平均价的。

```sql
SELECT product_type , product_name, sale_price
FROM Product AS P1
WHERE sale_price > (
SELECT AVG(sale_price)
FROM Product AS P2
WHERE p1.product_type = p2.product_type
GROUP BY product_type);
```

外层查询先产生多个结果，子查询会循环外层的结果，对外层每一个`product_type`进行计算产生一个`avg`。

## 表连接

- 内连接：选出两张表中互相匹配的记录
- 外连接：分为左外连接，右外连接
  - 左外连接：包括没有右表记录匹配的左表记录
  - 右外连接：包括没有左表记录匹配的右表记录

## 删除

**Drop：**直接删除表，包括数据和表结构，和依赖表的索引存储过程等。

**Truncate：**删除表的数据，不删除表结构，表和索引所占的空间会被初始化。

**Delete：**删除表的数据，可以有where条件，不删除表结构，表和索引所占空间不变。且删除操作会被日志记录。

## Like操作符

**%**  百分号可以匹配任意个字符

**_**    下划线只能匹配一个字符 

匹配以'yes'开头的记录`select * from xx_table where xx_name like 'yes%'`

匹配包含'yes'的记录`select * from xx_table where xx_name like '%yes%'`

匹配以'yes'结尾的记录`select * from xx_table where xx_name like '%yes'`，若有'yes '，即后面有空格不会匹配。

匹配'油'前只有一个字符的记录，若要匹配两个字符需要两个`_`。

```sql
select * from smbms_bill where productName like '_油';
```

## Count

count(1)与 count(*) 差不多，优于count(列名)。

count(列名)不会计入null，count( *)与count(1)会计入。

无论是否有主键，普通索引，主键索引。不过有索引count会优先使用索引。

总结：==InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference.==[出自文档]([https://dev.mysql.com/doc/ref...](https://dev.mysql.com/doc/refman/5.7/en/group-by-functions.html#function_count))

## SQL执行慢的原因

- 偶尔执行慢

执行SQL对数据进行修改时，修改的是内存中的数据，mysql会先在redo log日志中记录操作，然后在空闲的时候再把redo log的数据持久化到磁盘。如果数据库更新操作频繁，redo log很快被写满，又没有空闲时间，所以必须得先持久化到磁盘，暂停其他操作，所以导致SQL执行慢

- 经常执行慢

SQL语句问题：可能字段没有索引，或者没有用到字段索引。

**不走索引的原因**

对于非主键索引，B+树存储的是主键的值，然后再去走主键索引找到数据行，这就要走两次索引。mysql会判断走非主键索引扫描的次数少还是全表扫描的次数少，但是mysql也不知道符合条件的字段有多少行，如果全部符合还不如全表扫描。所以mysql有可能全表扫描而不走索引。

**mysql如何判断是否走索引**

根据索引的区分度：一个索引上不同的值越多，意味出现相同数值的索引就越少，意味着索引区分度越高，把这个区分度称为基数，所以区分度越高，基数越大。

mysql会根据索引采样获得基数，采样就会发生误差，由此mysql计算失误导致不走索引。

## 索引

一个管理数据排序，满足特定查找算法的数据结构。一般为B+树实现。

**优点：**加快查询速度，加快需要排序的查询效率，唯一性索引还能保证列数据的唯一性。

**什么样的列上需要加索引：**频繁查询的列，带有where条件，或者范围条件的。主键列和外键列。

**什么样的列不要加索引：**很少查询的列，数据内容极多或者极少的，有大量重复数据的。

**B树索引和哈希索引**

B树索引由B+树实现，查询过程中需要通过扫描树节点。

哈希索引由于计算哈希值，可以直接定位数据行。

B树索引可以进行范围查询和等值查询，哈希索引只能进行等值查询和in查询。

B树索引对于组合索引可以利用部分进行查询，哈希索引不能，因为是由组合列合并计算出的哈希值

**聚簇索引**

一种数据存储方式，具体实现依赖存储引擎。数据行的物理顺序与列值的**顺序相同**。

索引的叶子节点包含了数据行。InnoDB会为主键创建聚簇索引，如果没有主键，会用唯一性索引的列代替，如果没有，InnoDB会隐式定义一个主键创建聚簇索引。

**非聚簇索引**

索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。

 叶子节点保存的不是指向行数据的指针，而是主键索引的id值。

**索引覆盖**

查询的列正好是索引列时，直接通过索引的数据返回，无需回表，速度更快。

**创建索引的原则**

1. 选择唯一性索引
2. 选择数据量少的索引
3. 为经常需要做查询条件，排序，分组，联合的字段创建索引
4. 最左前缀匹配原则
5. 选择区分度高的作为索引，区分度：`count(distinct col)/count(*)`
6. 尽量扩展索引，不新建索引。
7. 索引列不能参与计算

**自适应哈希**

InnoDB会监控表的索引使用情况，如果认为哈希索引可以增加效率，那么InnoDB会自动在内存中自适应哈希缓冲区创建哈希索引。

**为什么索引用B+树实现**

两个事实

- 不同存储级别直接的IO速度差别很大，尤其对于磁盘来说是ms级，所以要想更快就必须减少IO次数
- 磁盘是页存储，读取1B数据和1KB数据速度一样。而且程序有个局部性原理，运行时在磁盘中需要数据周边也可能是需要的数据。

为什么B树

- 通过对磁盘批量访问的支持，B树的节点一般根据磁盘块大小设置，里面存储的是指向下层节点的关键字，若一个块大小为1KB，一个关键字为4B，这一个节点存储256个关键字。每次找到关键字范围，就进行一次IO，到下一层查找。

> 如果对数据进行添加时，当前节点位置已被占满，就要进行节点分裂，即原节点分裂为两个节点，它们的数据平分，进而需要多添加一个父节点指针，如果父节点已满，则进行父节点的分裂。

- 对于1亿的数据量，B树只需要查$\log_{256} 1e8$，大概四次IO

## 事务

**特性**

- 原子性：事务内操作不可分割，要么全部成功，要么全部失败
- 一致性：对于使用者来说，满足业务特定的规则。
- 隔离性：一个事务在执行过程中修改了表中的数据，在这个事务提交之前，其他事务对它的修改不可见
- 持久性：事务一旦提交就必须持久到磁盘。

**事务并发问题**

脏读：事务A读到了事务B未提交时修改的数据。

不可重复读：事务A在重复读相同的数据时，数据不一致。被事务B修改提交了。

幻读：事务A在执行时查询某个数据，而事务B进行数据的插入正好满足了事务A查询的条件，并提交。当事务A再进行相同的查询时数据时发现数据多了，产生幻读。

==不可重复读与幻读都是读到了其他事务提交的数据，只是不可重复读是其他事务update操作，幻读是其他事务的insert，delete操作==

**事务隔离级别**

- 未提交读：在事务A未提交时，事务B可以读取数据。这个级别什么都避免不了。
- 提交读：事务A提交之前修改的数据，事务B不可读。写事务对数据行进行加锁，事务提交释放锁，避免了脏读。
- 可重复读：事务A在提交前反复读取相同数据是一致的。
- 串行化：所有事务串行执行，没有并发安全问题。所有并发问题都没了。

**原子性实现原理**

事务在执行更新操作时，会在undo log中记录一条与更新操作相反的SQL语句，当发生错误需要回滚时就通过undo log回滚。

**持久性实现原理**

事务在执行完一个修改操作，就会记录入redo log 缓存中，每次事务提交后redo log会从内存缓冲中写入磁盘。

查询数据库表由于反复进行IO操作效率很低，所以mysql有一个数据表页的缓冲池，每次修改，读取数据都从缓冲池中获取数据。如果在缓冲池的数据在系统宕机时丢失，重启时就可以通过重做日志恢复数据。由于数据表的IO一般是随机的，且数据量比较大，每次事务提交追加重做日志数据小，且是顺序IO，所以可以通过重做日志实现持久性。

**隔离性实现原理**

未提交读：不加锁，出现脏读。

提交读：写操作的事务A对数据加写锁，事务B在A提交前就不能查询修改数据，避免脏读。

可重复读：MVCC，间隙锁。避免脏读，不可重复读，部分幻读。

- 可重复读通过基于乐观锁的MVCC，在事务查询操作获得数据版本号小于等于当前事务版本号，删除版本号大于当前事务的数据生成快照，即为快照读，避免了脏读和不可重复读。
- 可重复读通过间隙锁能防止部分幻读。在事务进行修改操作时，mysql会通过间隙锁对修改数据的上下范围进行加锁，具体是通过一个非聚簇的B+树索引，找到该数据对应的叶子节点，锁住该叶节点前后节点范围的数据。

## 优化

查询语句执行顺序：from，where，group by，having，select，order by

1. 字段设置不允许为null：==如果出现null，在用 "!=" 符号匹配时匹配不到为null的数据行。==如果要匹配null数据行条件需要加`or columnName is null`，`is`不能换成`=`，否则也匹配不到。
2. 尽量用`union`代替`or`：对于同一个字段的两个条件，or不会走索引，而union会。
3. 能用`exist`就不用`in`：exist只要查到一行满足条件的数据就终止查询，in需要扫描全表。in后面如果是子查询会先执行子查询，并将结果保存在一个视图中，然后扫描视图，exist不会生成视图。
4. 对于`not in`子查询中如果有null值不会返回结果。`not exist`没有这种限制
5. 数据库的解析器按照**从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表将被最先处理**。如果三个表完全无关系，选择记录最少的表放到最后。如果有关系，选择被其他表引用最多的表放在最后。
6. `where`条件是从左到右解析，能过滤大部分数据的条件写在左边。
7. `select`避免用*。

## 锁

mysql有行锁，页锁，表锁。

行锁粒度最小，开销最大，并发度最高。

表锁粒度最大，开销最小，并发度最低。

页锁介于两者之间。

**悲观锁**

认为每次获取锁有可能失败，事务开始先获取锁，再执行操作。

**乐观锁**

认为读的情况永远比写多，先不去获取锁，在事务提交前去查看更新数据有没有被修改过，若有就回滚，没有则执行成功。

实现乐观锁需要数据库的一些支持，比如在数据行后加版本号或者时间戳，在事务开始时先获取当前版本号，事务提交前查看对应数据版本号是否被修改，若是就回滚，不是就执行成功。

如果要求响应速度，使用乐观锁。如果冲突频率较高，使用悲观锁。

## 日志

### binlog

binlog记录数据库执行时写入型操作（不记录查询操作）。它是逻辑日志（记录的是SQL语句），以二进制形式记录在磁盘中，它是追加文件写入，可以设置日志文件最大值（到达指定值新建一个日志文件）。它由server层记录。

**应用场景**

- 主从复制：Master端开启binlog，发送到slave端，使其达到数据一致。
- 数据恢复。

**刷盘时机**

对于InnoDB，事务提交时才会记录binlog，此时数据还在内存中，mysql通过`sync_binlog`参数控制刷盘时机，可设置系统判断、事务提交就刷盘，每N个事务提交就刷盘等方式。

**binlog三种格式**

- statement：基于SQL语句的复制
- row：基于行的复制（即记录哪条数据行被修改了）
- mixed：statement和row混用

### redolog

为了在数据持久化的时候避免频繁读写磁盘，造成性能问题，mysql设计了redolog记录事务对哪些数据进行了修改，在空闲时刷回磁盘。

redolog包含两部分，一个是内存中的日志缓冲区，一个是磁盘的日志文件。mysql每执行一次SQL，先将记录写入redolog缓冲区，后续再将缓冲区的记录一次性写到日志文件。

不过用户空间的缓冲区需要通过OS buffer才能写入日志文件。

mysql可通过`innodb_flush_log_at_trx_commit`设置redolog缓冲区写入日志文件的时机。

1. （0）延迟写，事务提交不会写入OS buffer，而是每秒从redolog buffer写入OS buffer并调用`fsync()`写入日志文件
2. （1）实时写、实时刷，每次事务提交都会写入OS buffer并刷入磁盘。
3. （2）实时写、延迟刷，每次事务提交写入OS buffer，每秒从OS buffer刷入磁盘

**redolo格式**

redolog记录的是数据页的变更，这种记录在数据持久化后不需要全部保存，因此redolog采用大小固定，循环写入的方式。

**redolog和binlog区别**

- redolog文件大小固定，binlog可设置。
- redolog是存储引擎层实现的，binlog是服务层实现。
- redolog适用于崩溃恢复，binlog适用于数据的一致和恢复。

### undolog

记录与数据库更新SQL语句相反的语句，实现了事务的原子性。

# Redis

## Redis为什么快

单线程，没有线程切换的开销。在内存中，读取速度较快。

## 缓存穿透

用户在查询数据时，如果在缓存中没有找到，且数据库中也没有，而用户反复到数据库请求数据，这样会给数据库的访问造成很大压力。

**解决方案**

- 缓存空对象：如果请求发送过来，缓存和数据库中都没有，就返回一个空对象，并在缓存中存储这个请求与空对象。等下次有相同请求时返回这个空对象。以减少数据库压力。如果需要缓存的空对象过多，可以设置空对象的过期时间，避免内存浪费。
- 布隆过滤器：对于大量相同的请求，这个用户可能是攻击者，可以通过布隆过滤器晒掉这些请求。

## 缓存击穿

对于某个key经常被查询(热点数据)，如果这个key突然过期失效，在大并发情况下对这个key访问时，由于缓存中找不到，请求压力就会直接打在数据库上导致数据库瘫痪。

## 缓存雪崩

假设对于一个商城页面的所有热点key都是12个小时失效，假设零点有一个秒杀活动，但是此时热点key都失效了，那么此时所有请求都会落在数据库上，可能来不及数据库报警就挂了。但是重启数据库可能又被大流量打死。

即同一时间大面积key失效。解决方法就是key的失效时间设置为随机值。如果是集群部署时，可以设置热点key在不同的服务器。

## Key 淘汰策略

### volatile-lru

键设置过期时间，淘汰最近最久未使用的key.

### allkeys-lru

对所有键实行lru.

### volatile-random

对键设置过期时间，随机移除一个key

### allkeys-random

随机移除一个key

### no-eviction

内存使用达到阈值时，所有内存申请命令报错

## Key如何淘汰

1. 定时删除：设置闹钟，时间到了删除。对内存友好，如果键多了对cpu不友好。
2. 惰性删除：每次获取键时检查键的过期时间，如果过期就删除。
3. 定期删除：隔一段时间就去检查数据库，删除过期的键。

# Java

## 多态

多态是同一个行为具有多个不同表现形式或形态的能力。

## hashcode和equals

hashcode是一个native方法，返回的是一个int类型。equals用于比较两个对象的相等情况，在Object类中默认实现为hashcode的比较。

在集合中，如hashmap，它先是通过键的hashcode定位到数组下标，在通过equals判断是否相等，再加入链表或者红黑树。如果集合中存放自定义类型，对于属性值相同的对象，一般都希望他们代表的意义相同，所以需要通过重写equals方法断定两个对象相同。如果不重写，就会得到两个内容相同的对象，造成应用上的歧义。

有这样一个规定，hashcode相同equals不一定为true。equals为true hashcode一定得相同。

## 注解

注解告诉程序被标识的类，方法，属性该如何处理。注解通过反射读取，如spring如果配置了包扫描，它读取到一些组件注解后，就会把对应的类加入IOC容器。

## 反射

JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。

- **优点：** 运行期类型的判断，动态加载类，提高代码灵活度。
- **缺点：** 1,性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。2,破坏类的封装，让我们可以动态操作改变类的属性同时也增加了类的安全隐患。

**为什么需要反射**

很多项目中的实际设计都需要反射，模块化开发，动态代理设计模式也用到了反射。

应用场景：Spring的 IOC 容器，反射+工厂模式 使工厂类更稳定，JDBC连接数据库时加载驱动类

## 序列化与反序列化

序列化就是把一个对象转换为字节序列，方便传输。

反序列化就是把对象生成的字节序列读取出并生成对象。

**serialVersionUID**

序列化ID，是序列化前后唯一的标识符，如果没有手动定义，编译器会自动生成。若果类的结构信息修改了，序列化ID也会变动。所以建议手动设置序列化id。

在反序列化时，jvm会比对字节序列中的id与被序列化类的id，如果不一致，会报错。

对于`static`、`transient`修饰的对象不可序列化。

static很好理解，因为属于类变量，不属于对象。

transient指定某个字段不可序列化，比如密码。

**问题**

序列化，反序列化在数据传输过程中如果被恶意修改，得到的对象就有风险了。

所以要控制构造出的对象，可以通过重写`readObject`方法，在其中判断数据是否有效。

****

## CopyOnWriteArrayList

**Vector和SynchronizedList的问题**

这两个容器在多线程环境下，遍历过程中另一个线程对其增加或删除元素是会产生问题的，所以需要手动加锁。`ConcurrentModificationException`

但是遍历都要加锁，十分划不来，所以就有了COW。

> CopyOnWrite
>
> 如果有多个调用者请求相同的资源（如内存或磁盘数据），他们会获得相同的指针指向同一份资源。如果有调用者需要修改资源数据，操作系统会给为其复制一份专用副本给调用者，其他调用者所看见的内容不变。因此多个调用者只有读操作时可以共享一份资源。

- CopyOnWriteArrayList是线程安全容器(相对于ArrayList)，底层通过**复制数组**的方式来实现。
- CopyOnWriteArrayList在遍历的使用不会抛出ConcurrentModificationException异常，并且遍历的时候就不用额外加锁
- 元素可以为null

**常用方法**

- `add()`：通过复制一份新数组，进行修改，然后赋值给`array`(Object数组，成员变量)
- `get()`：直接访问数组
- `set()`：复制一份新数组，修改，引用赋值给`array`
- `remove()`、`clear()`跟`set()`和`add()`是类似

**为什么遍历时不用加锁**

在其他线程完成修改操作之前，遍历获得到的数据都是原数组中的数据，它用`snapshot`引用了当前的数组对象，所以即使其他线程对数据进行了修改（创建了新数组），不影响当前遍历的数据。

**缺点**

- 耗内存，由于修改操作需要频繁创建移动数组。
- 只能保证数据的最终一致性。换句话说不能保证实时一致性。

## HashMap

HashMap是一个由数组和链表实现的可以快速查找的集合。它里面有一个内部类Node，存储键和值。Node即为Node数组存储。

HashMap有一个属性threshhold阈值，和loadfactor加载因子。在创建HashMap时如果不指定Capacity，默认HashMap size为16，加载因子为0.75。HashMap构造函数可以进行容量和加载因子的构造函数，若指定了容量，它会把容量设置为最小大于当前传入cap的2次幂。阈值则为size*loadfactor，当数组元素超过阈值时则需要扩容。

HashMap初始化时懒加载的，是在put方法中如果数组未初始化，就进行初始化。或者扩容。扩容是把数组大小扩大两倍，并且重新移动数组内元素，通过原来的数组长度加上键的hash值。

put操作中先通过key计算hash值，再通过key&len-1计算出数组下标，判断是否发生冲突，如果为空，就新建链表节点加入数组。如果不为空，则遍历链表进行equals比较，如果找到相同的元素就进行val的替换，如果没有就加入链表尾部。如果链表个数大于8且数组长度大于64，则需要链表转为红黑树。如果是红黑树则进行红黑树的插入。然后查看size是否超过阈值，如果超过则需要进行扩容。

get操作和put类似，只是不需要扩容操作。

扩容操作：如果数组未初始化，那么先进性数组初始化。如果threshhold不为零数组大小设置为其值，否则设置为16。如果数组已初始化，那么新建一个两倍长度的数组，重新计算节点hash值，从旧数组移动到新数组（hash和oldCap做与运算，如果为0位置不变，如果为1则数组位置为原位置索引+oldCap）

![image-20200815190030243](面试题整理.assets/image-20200815190030243.png)

**数组大小为什么要设置2幂次**

1. 在确定数组下标时，用的是`hashcode & arr.length - 1`，也可以用%运算，但是当数组长度为2的幂后，&运算与%结果相同，且&更高效。
2. 2幂次减一会造成所有位都为一，在与hashcode进行&运算时，会使每个位都得到计算，降低了哈希冲突的情况。例如最后一位为0，不论hashcode运算的那个位是何值，结果始终为偶数，就少利用了一半的数组空间。

**为什么加载因子0.75**

加载因子过小，空间利用率不高。加载因子过大，操作的时间复杂度退化。

**多线程不安全**

1.在JDK1.7中，当并发执行扩容操作时会造成环形链和数据丢失的情况。
2.在JDK1.8中，在并发执行put操作时会发生数据覆盖的情况。

## ConcurrentHashMap

- **底层结构是散列表(数组+链表)+红黑树**，这一点和HashMap是一样的。
- Hashtable是将所有的方法进行同步，效率低下。而ConcurrentHashMap作为一个高并发的容器，它是通过**部分锁定+CAS算法来进行实现线程安全的**。CAS算法也可以认为是**乐观锁**的一种~
- get方法是非阻塞，无锁的。重写Node类，通过volatile修饰next来实现每次获取都是**最新**设置的值
- **ConcurrentHashMap的key和Value都不能为null**

## 迭代器为什么不定义为类

如果是类，我们创建该类的对象来遍历各种集合，但是各种集合实现的数据结构是不一样的，我们不可能把所有集合的遍历方式都写到一个类里面。所以把迭代器定义为接口，规定迭代器的操作方法，具体由各个集合的内部来实现。

## 进程和线程的区别

进程是可以独立运行的程序。线程必须在进程内部运行，不能脱离线程存在。

进程是操作系统资源分配的基本单位。线程是CPU调度的最小单位。

进程的创建，资源消耗比较高。线程创建，资源消耗低。

进程间通信比较麻烦，线程因为共享内存，通信比较方便。

多进程程序一个进程死掉依然能执行。一个程序内有一个线程死掉程序就死掉。

## 线程通信方式

**Synchronized：**同步执行，线程执行完同步块，其他线程才能继续执行。

**while轮询：**线程不停的判断某个条件，当另一个线程把条件修改好后，线程结束。没啥用处。

**wait/notify：**线程在执行时发现条件不满足，就等待，让出cpu给另一个线程，等另一个线程调用notify唤醒它。

**管道：**

## 线程池

线程的集合。在没有任务时处于空闲状态，在需要多个线程处理时分配出线程执行任务，执行结束并不销毁，而是返回线程池，等待下次调用。这样的好处：减少频繁对线程生命周期的管理，一定程度提高性能。

**Callable接口**：作为需要执行的任务传入线程池`pool.submit(()->{xxx})`。

**Future接口：**接收线程池执行完任务返回的结果。

**ThreadPollExecutor**

线程池执行器。

- **corePoolSize，maxiumPoolSize**
  - 如果当前运行线程数目小于核心数，则创建新线程（即使其它线程空闲）
  - 如果当前线程池运行的线程数目大于核心数目，小于最大数目，在阻塞队列满时才会创建新线程。
- **KeepAliveTime**：非核心线程空闲的时长如果超过该值，就会被销毁。
- **BlockQueue**：阻塞队列，里面包含任务（Runnable，Callable）对象，
- **ThreadFactory**：批量创建线程的工厂，属于一个线程组，没有优先级和守护线程。
- **RejectedExecutionHandler**：当运行线程大于最大线程数，会拒绝任务，拒绝任务的策略。

ThreadPoolExecutor里面有一个调度线程，用来管理线程池中的线程执行任务，维护阻塞队列等等。线程池也有自己的状态：

- RUNNING：能够接收新任务。
- SHUTDOWN：不接收新任务，但处理当前剩余的任务。
- STOP：不接收新任务，不处理剩余的任务，甚至中断当前任务。
- TIDYING：所有任务执行完毕，ctl记录的任务数为0。接着会执行Terminated函数
- TERMINALTED：线程池终止执行。

**三个常见线程池**

1. newFixedThreadPool，固定数目线程池，核心线程和最大线程设置数目一致。
2. newCachedThreadPool，弹性线程数目，核心线程数目为0，最大线程数目为`Integer.MAX_VALUE`。如果新任务没有空闲线程，立即创建一个新线程执行。
3. SingleThreadExecutor，单个线程的线程池

可通过ThreadPoolExecutor构造函数自定义线程池，自定义上述参数。
任务排队策略

- 同步移交：不放到队列，等待线程来执行，如果当前没有空闲线程，这创建新线程执行。
- 无界限策略（LinkedBlockQueue）：如果核心线程都在工作，当前任务加入工作队列等待。
- 有界策略（ArrayBlockQueue）：可以避免资源好近，但减少了吞吐量。

任务拒绝策略

- 直接抛出异常
- 返回给调用者线程
- 抛弃这个任务
- 抛弃队列最老的任务

线程池关闭

- shutdown：调用该方法，线程池进入shutdown状态，执行完剩余等待的任务，然后进入终止状态。
- shutdownNow：线程进入STOP状态，然后进入终止状态。

回收多余线程



## 锁类型

**重量级锁：**得不到锁立马进入阻塞状态。

**自旋锁：**得不到锁会进行等待，然后再次尝试，在超过一定时间后才进入阻塞状态。

**自适应自旋锁：**自旋锁可以设置循环的次数，而自适应自旋锁会自己判断等待的时间，如果对一个锁不久之前拿到过，它就认为获得这个锁的几率比较大，把等待时间设置少一点，如果锁从未拿到过，等待时间就长一点。

**轻量级锁：**由于加锁释放锁开销比较大，频繁加锁会影响性能，所以有了轻量级锁。当线程进入一个方法时，做一个标记，当有其他线程看到这个标记时，就代表该方法有线程在执行，不能进入。当线程执行完时，修改回标记。（CAS机制）。当线程之间有锁竞争时，轻量级锁就不适合了，它适合线程竞争锁很少的情况。

**偏向锁：**轻量级锁已经很方便了，偏向锁觉得不行还得再省事一点。它以为只有自己一个线程，进入方法后修改标志位，并且吧自己的线程ID页记录进去，执行完方法时不修改标志位，当下次执行时发现线程ID还是自己的就直接进去执行。当下次执行发现不是自己的ID，偏向锁就会升级为轻量级锁。

==轻量级锁就是一种乐观锁，认为不加锁也没事，先不加锁，有冲突再解决==

轻量级锁上面的锁在进入方法前一定要加锁的就是一种悲观锁。

## Volatile

程序在执行的时候，需要CPU进行指令的执行。而指令执行需要对数据的读取和写入。而程序运行时是在内存当中的，CPU执行指令的速度远大于从内从中读写数据的速度，所以CPU就有了高速缓存，程序执行时先把一部分指令复制到缓存，当CPU执行完缓存的数据时在把数据刷回内存。

对于多核CPU，每个线程可能执行与不同的CPU中，每个CPU有自己的高速缓存，当多个线程从内存中读取数据到高速缓存时，他们对数据的修改就可能造成不一致问题，就造成线程不安全问题。

**Java线程安全的处理**

java可通过volatile，Synchronized关键字处理线程不安全的问题。

java内存模型规定，所有变量都存于主存中（物理内存），每个线程有自己的工作内存（高速缓存），线程对变量的修改必须复制到工作内存中进行，不能对主存直接操作。线程不能互相访问工作内存

### 可见性

线程对共享变量的修改成功后，其他线程知道这个变量被修改了，就去主存中重新读取数据。如果一个共享变量被volatile修饰，那么它就保证是可见的。

> ==可见性原理：==被volatile修饰的变量在编译为指令后，会多一条有lock指令的操作`lock addl $0x0,($esp)` 它会锁住数据传输总线，使得其他线程不能访问，使得该线程独享该数据区域，保证多线程操作的安全。

> 由于总线被堵住影响多核CPU的执行效率，所以后来的处理器在遇到lock指令不会锁住总线，它先锁住缓存内部的区域 ，修改完刷回内存时利用==缓存一致性协议==保证多个处理器中缓存的一致性。

**缓存一致性协议**

处理器会一直在总线上嗅探自己缓存中的内存地址被其他处理器操作的情况，一旦发现自己缓存区域的内存地址的数据被其他处理器所修改，它就强制自己该缓存区域的地址无效。线程执行需要访问数据时，发现缓存无效，就重新去内存中读取。

### 有序性

编译器优化代码的时候可能会有指令的重排序，对于多线程的环境下可能造成线程不安全问题。

volatile可以保证该变量不会与之前的代码重排序。

**无法保证线程安全的原因**

java的运算操作不是原子操作，先从内存读取数据，再进行运算，再把结果刷回内存。这三个过程任何一个都有可能被打断，CPU执行一半取执行其他线程了。所以在多个线程操作共享变量时，有两个线程都读取了变量值，一个线程进行了计算但没有刷回内存，CPU又去执行第二个线程，它发现内存中的数据没被修改，所以自己的高速缓存有效，进行计算，然但实际这个数据已经失效了。

## Atomic

- 原子性是指一个操作不可分割。

多线程中，因为很多操作不是原子性，导致数据不一致的问题。比如`count++`，这个操作是先读取数据的值，再进行加一操作，再放回内存中。

java中有atomic包的工具类来保证原子性。

- 可见性是指共享变量在多线程的环境下：一个线程对变量的修改，其他所有线程都知道该变量被修改。

java中有`volatile`关键字能保证变量的可见性，但是不保证变量的原子性，变量的修改在jvm有好几步操作。

**volatile保证了三点**

1. 一旦完成写入，任何访问该变量的线程都会得到最新值。
2. 保证写入前，其他任何线程对变量的修改已经完成。
3. 防止指令重排序，程序执行时，CPU、编译器可能会对指令进行一些调整。声名了volatile的变量，CPU、编译器就知道这是共享变量，通过内存屏障避免重排序。

### CAS

比较并交换，原子操作的一种。在多线程环境中实现不被打断的数据修改操作。

> CAS 有三个操作数：旧预期值、内存值、修改的新值。
>
> 当预期值与内存值相等时，线程可对变量进行修改。
>
> 不相等，可以再次尝试（自旋），也可以什么都不做。

**自旋**

两个线程A，B。当A，B都要修改共享变量时，它们会读取内存值到工作内存，得到预期值。当A得到CPU时间片，B需要等待。A比较预期值与内存值，相等，则进行修改，并刷新到内存。A完毕，B执行，比较预期值与内存值，发现不相等，则修改预期值为当前内存值，并再进行一次比较，相同则进行修改。

**ABA问题**

现在有一个共享变量`count = 10`，三个线程A，B，C都去修改它。

1. A，C都读取到了内存值，并设置预期值为10。
2. 如果A先得到执行，它把count修改为20。
3. 接着B执行，它读到count预期和内存值都是20，把count修改回10
4. C得到执行，发现预期值和内存值依然相等，将count改为11

导致问题，线程C不知道变量已经被A,B修改过。对于基本类型可能影响不大，对于引用类型（如链表）这样是有风险的。

**解决**

对数据加一个版本控制，修改后更新版本，这个版本实际由时间戳决定，当线程

## AQS

- AQS是一个实现锁的框架，其关键是队列（FIFO）和同步状态
- ConditionObject内部类
- 有两种线程模式：共享、独占
- lock包中相关锁都依赖AQS构建
- 一般称为AQS同步器

**细节**

> 同步状态由volatile修饰，保证多线程可见，修改状态由CAS实现。

```java
private volatile int state;
protected final boolean compareAndSetState(int expect, int update) {
    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}
```

> 同步队列（CHL）由双向链表实现；线程在获取锁失败时进入同步队列。AQS维护其首尾节点；链表节点为内部类Node。

```java
static final class Node {
    //共享
    static final Node SHARED = new Node();
    //独占
    static final Node EXCLUSIVE = null;
    //线程被取消
    static final int CANCELLED =  1;
    //后继线程需要唤醒
    static final int SIGNAL    = -1;
    //等待condition唤醒
    static final int CONDITION = -2;
    //同步状态传播下去，不懂
    static final int PROPAGATE = -3;
    //上面几种情况
    volatile int waitStatus;
    volatile Node prev;
    volatile Node next;
    //指向下一个等待在condition的线程 
    Node nextWaiter;
}
```

> ConditionObject，内部类，维护了一个等待队列，节点也为Node
>
> Lock实现的同步器中，newCondition方法返回的就是一个ConditionObject对象。
>
> 这个对象就是让当前线程进入它的等待队列。
>
> 任何调用它`await`方法的线程都会被加入ConditionObject的等待队列，其他线程需要通过该ConditionObject的`signal/signalAll`方法唤醒它，让其加入同步队列。

**常见方法**

- `acquire()`这个方法会通过子类实现的`tryAcquire()方法`尝试获取资源，如果获取失败则加入等待队列。在队列中，如果前置节点为头结点，则会继续尝试获取资源。如果前置节点为`signal`状态，则中断当前线程。否则就持续尝试，直到被`park`或者获取到资源。
- `release()`这个方法通过调用子类实现的`tryRelease()方法`释放锁，然后唤醒后继节点。如果后继节点是作废状态，则从队列尾部开始找合适的节点。

总的来说，AQS实现了对同步状态的管理，以及对阻塞的线程进行排队，通知处理。它定义了对线程获取锁，释放锁，中断，超时等待这些模板方法，里面的具体方法有子类实现。

## Lock

- Lock可以设置公平与非公平锁，支持中断，可设置超时时间。

- 灵活性高，使用更明晰，但需要手动加锁、释放锁。
- 支持条件对象。
- 细分读写锁，可允许多个线程获取同一个读锁。

大多数情况用Synchronized关键字，需要用到Lock特性时再取用Lock锁。

Lock解决的是syn不能轮询和定时获取锁，不能设置公平与非公平的问题，粒度相对细。

## ReentrantLock

- ⽐synchronized更有伸缩性(灵活)

- ⽀持公平锁(是相对公平的)

- 使⽤时最标准⽤法是在try之前调⽤lock⽅法，在finally代码块释放锁

## ReentrantReadWriteLock

ReentrantLock是互斥锁，一个线程进入临界区必须加锁，阻止其他线程进入。

ReentrantReadWriteLock使得线程在读操作时可以一同进入临界区，写操作是互斥进入临界区。

- 读锁不支持条件对象，写锁支持
- 读锁不能升级为写锁，写锁可以降级为读锁。
- 读写锁也有公平与非公平模式

## CountDownLatch

一个同步辅助类，初始化时设置一个数值`count`。其他线程进行操作的同时减小这个数值。主线程在`count`不为零的情况下等待，直到`count=0`继续执行。

```java
public static void main(String[] args) {

  final CountDownLatch countDownLatch = new CountDownLatch(5);

  System.out.println("现在6点下班了.....");

  // 3y线程启动
  new Thread(new Runnable() {
    @Override
    public void run() {

      try {
        // 这里调用的是await()不是wait()
        countDownLatch.await();
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
      System.out.println("...其他的5个员工走光了，3y终于可以走了");
    }
  }).start();

  // 其他员工线程启动
  for (int i = 0; i < 5; i++) {
    new Thread(new Runnable() {
      @Override
      public void run() {
        System.out.println("员工xxxx下班了");
        countDownLatch.countDown();
      }
    }).start();
  }
}
```

## CyclicBarrier

线程到达某个状态后，暂停，等待所有线程都到达这个状态，再继续执行。

```java
public static void main(String[] args) {
  CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> {
    System.out.println("ok。。");
  });
  for (int i = 0; i < 7; i++) {
    final int temp = i;
    new Thread(() -> {
      System.out.println(Thread.currentThread().getName() + " 收集了第" + temp + "个");
      try {
        cyclicBarrier.await();
      } catch (InterruptedException e) {
        e.printStackTrace();
      } catch (BrokenBarrierException e) {
        e.printStackTrace();
      }
    }).start();
  }
}
```

## Semaphore

控制可以有多少线程进行访问。创建时指定个数，代表有多少许可证。

- `aquire()`方法消耗一个许可证，许可证消耗完就会阻塞。
- `release()`方法归还一个许可证

许可证其实就是个count变量。

```java
public static void main(String[] args) {
  // 假设有30个同时来到酸奶店门口
  int nums = 30;
  // 酸奶店只能容纳5个人同时挑选酸奶
  Semaphore semaphore = new Semaphore(5);
  for (int i = 0; i < nums; i++) {
    int finalI = i;
    new Thread(() -> {
      try {
        // 有"号"的才能进酸奶店挑选购买
        semaphore.acquire();
        System.out.println("顾客" + finalI + "在挑选商品，购买...");

        // 假设挑选了xx长时间，购买了
        Thread.sleep(1000);

        // 归还一个许可，后边的就可以进来购买了
        System.out.println("顾客" + finalI + "购买完毕了...");
        semaphore.release();
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }).start();
  }
}
```

## Synchronized实现原理

每一个对象都有一个监视器锁，线程进入同步块时需要获得这个锁，当线程执行到monitor enter指令时，线程会尝试获取monitor，获取到就进入同步块，进入数设置为1。其他线程尝试获取锁会失败被阻塞。如果当前线程已经占有monitor，重新获取锁，进入数加一。执行monitor exit指令时释放锁，进入数减一，当进入数为零代表当前线程已释放monitor，其他线程可以获取monitor锁。

1、线程解锁前，必须把共享变量的最新值刷新到主内存中； 
2、线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量是需要从主内存中重新读取最新的值（加锁与解锁需要统一把锁） 

**为什么有显式锁还需要Synchronized**

syn控制简单，lock面向对象的管理锁不方便。代码更容易维护。

## Thread

**继承Thread和实现Runnable区别**

- 一个是继承类，一个是实现接口
- 对于继承Thread，创建对象代表创建一个线程，每个线程对自己的成员变量独有。而Runnable相当于创建任务，即使`Thread(Runnable)`创建了多个线程，但他们执行的是一个任务

```java
class MyThread extends Thread {
    private int ticket = 10;
    private String name;

    public MyThread(String name) {
        this.name = name;
    }

    public void run() {
        for (int i = 0; i < 500; i++) {
            if (this.ticket > 0) {
                System.out.println(this.name + "卖票---->" + (this.ticket--));
            }
        }
    }
}

class MyThread1 implements Runnable {
    private int ticket = 10;
    private String name;

    public void run() {
        for (int i = 0; i < 500; i++) {
            if (this.ticket > 0) {
                System.out.println(Thread.currentThread().getName() + "卖票---->" + (this.ticket--));
            }
        }
    }
}
class ThreadDemo {
    public static void main(String[] args) {
        //每个线程都卖十张票
        MyThread mt1 = new MyThread("一号窗口");
        MyThread mt2 = new MyThread("二号窗口");
        MyThread mt3 = new MyThread("三号窗口");
        mt1.start();
        mt2.start();
        mt3.start();
        //三个线程卖十张票
        Thread t1 = new Thread(mt,"一号窗口");
        Thread t2 = new Thread(mt,"二号窗口");
        Thread t3 = new Thread(mt,"三号窗口");
        t1.start();
        t2.start();
        t3.start();
    }
}
```

## 线程的一些方法

**wait：**当前线程在执行到这个方法时会等待阻塞，并释放对象monitor锁。其他线程就可以获得monitor锁，并且其他线程通过notify或notifyAll唤醒当前线程才能继续执行。

**notify/notifyAll：**当前线程通过这个方法唤醒其他在monitor锁上等待的线程。

**sleep：**当前线程暂停执行一段时间，不释放monitor锁。

**yield：**当前线程暂时让出执行时间，给其他线程执行。但是这个让行是不确定的，有可能其他线程还没执行又返回当前线程了。

**join：**阻塞当前调动join方法的主线程，子线程执行完，被阻塞的主线程才会继续执行。join里面使用wait方法实现的，相当于主线程获取到了子线程的对象锁，然后被wait方法等待，直到子线程执行完毕唤醒主线程。

## ThreadLocal

线程本地存储。线程类中有一个ThreadLocal类里面的内部类`ThreadLocalMap`的属性，这个Map键为ThreadLocal，值为我们存放的数据。

当我们使用ThreadLocal时，可以通过set，get方法获取到我们设置的线程本地数据。

**原理**

每个线程都有自己的`ThreadLocalMap`

> 外部ThreadLocal对象是公有的，在每个线程调用set方法时是添加到自己的Map中去，公有ThreadLocal对象为键，数据为值。实现了线程私有。

```java
public void set(T value) {

    // 得到当前线程对象
    Thread t = Thread.currentThread();

    // 获取当前线程的ThreadLocalMap
    ThreadLocalMap map = getMap(t);

    // 如果map存在，则设置当前ThreadLocal为key，要存储的对象作为value存到map里面去
    if (map != null)
        map.set(this, value);
    //不存在就为当前线程创建map
    else
        createMap(t, value);
}
```

> get时也是通过外部ThreadLocal变量为键查到到map中放的数据。

```java
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}
```

**由于ThreadLocalMap的生命周期跟Thread一样长，且其Entry是弱引用，如果没有手动调用remove方法删除，key会被jvm垃圾回收，而对应的value不会，但没有key他就是无效数据，就会导致内存泄漏**

## 如何避免内存泄漏

1. 尽早释放无用对象
2. 少用静态变量
3. 使用内存池技术

## java11新特性

```java
static void inputStreamFeature() throws IOException {
    var t = new Main();
    var is = t.getClass().getClassLoader().getResourceAsStream("1.txt");
    System.out.println(is == null);
    try (var os = new FileOutputStream("2.txt")) {
      is.transferTo(os);
    }
    is.close();
  }

  static void optionalFeature() {
    Optional<String> op = Optional.ofNullable(null);
    //如果内部引用为空，返回参数中的引用
    String str = op.orElse("sad");
    String 八重樱 = op.orElseGet(() -> "八重樱");
    System.out.println(八重樱);
  }

  static void stringFeature() {
    System.out.println("\r".isEmpty());
    String str1 = "\r \n das  ";
    System.out.println("str1.trim:" + str1.trim().length());
    System.out.println("str1.strip:" + str1.strip().length());
    var lead = str1.stripLeading();
    var tail = str1.stripTrailing();
    System.out.println("幽兰黛尔".repeat(3));
    String s = "a \n b \n c \n";

    System.out.println(s.lines().map(String::strip).collect(Collectors.toList()));
  }

  static void collectFeature() {
    var date = LocalDate.of(2020, 2, 2);
    List<Integer> list = List.of(1, 2, 3, 34);
    Set<Integer> set = Set.of(1, 2, 3);
    var l = new ArrayList<>(list);
  }

  static void streamIteFeature() {
    Stream<Integer> stream = Stream.of(1, 3, 7, 2, 2, 5, 7, 9, 20, 44);
    var take = stream.takeWhile(t -> t % 2 == 1);
    take.forEach(System.out::println);
    //无穷多
    Stream<Integer> it = Stream.iterate(1, t -> t < 1000, t -> 2 * t + 1);
    it.forEach(System.out::println);
  }
```

## JVM

### **体系结构**

- 类加载子系统
- 运行时数据区：包含堆，方法区，虚拟机栈，本地方法栈，程序计数器。
- 执行引擎
- 本地方法接口，本地方法库

### **类加载过程**

1. 加载：获得类的字节流。把字节流内存储的数据转为方法区的运行时数据。在内存中生成一个代表此类的Class对象，作为方法区中这个类的各种数据访问入口。
2. 链接
   1. 验证：确保字节流中的信息是符合虚拟机要求的，不会危害虚拟机自身安全。
   2. 准备：为static变量设置默认值，这里不包括final修饰的static变量，因为在编译时它的值确定了，这里会显示初始化。
   3. 解析：将常量池的符号引用（class文件中的描述引用的符号）替换为直接引用（直接指针或者句柄）的过程。
3. 初始化：执行类构造器方法`clinit`的过程，这个方法不是手动定义的，是编译后如果有静态变量/块自动生成的，编译器会自动收集static变量，代码块的赋值语句，进行合并。生成的字节码指令顺序与源文件代码顺序一致。

**类加载时机**

- 遇到new 关键字类没有加载时
- 反射创建对象类没有加载时
- 初始化一个类，如果其父类没加载需要先加载父类
- 主启动类（包含main方法的）需要先加载

### **类加载器**

引导类加载器，扩展类加载器，应用程序类加载器。

### **双亲委派机制**

一个类加载器收到加载类请求时，不直接进行加载，而是交给它的上一级加载器加载，如果上一级还有更上一级，依次向上传递，直到引导类加载器。如果上层加载器找到对应的类，就进行加载，如果找不到就传给下一级。

- 好处

保护核心类库，如果自定义一个与核心类库全限定名相同的类，那么就不会加载自定义的类，因为扩展类加载器能找到核心包的类进行加载。

避免类的重复加载。

### 运行时数据区

**基本分区**

线程私有的：栈，本地方法栈，程序计数器。

线程公有：堆，堆外内存（方法区：元空间，永久代等）

**线程**

java程序不能真正创建线程，它需要调用本地c++方法创建线程。java中的线程对应一个操作系统的线程。java程序执行结束，线程也就被销毁了。

jvm有一些系统线程：编译线程，将字节码编译为本地代码。GC线程：进行垃圾回收的线程。信号调度线程。

**程序计数器**

它用来存储下一条要执行的指令地址，由执行引擎进行读取。

- 它是一块很小的内存空间，读取速度很快。
- 每个线程都有自己的计数器。
- 程序的分支，循环，跳转都靠这个来完成。
- 任何时候一个线程都只有一个方法在执行，也就是所谓当前方法，计数器存储的就是方法中下一条要执行的指令地址。如果是本地方法则为undefined

**java虚拟机栈**

==也叫java栈。栈是运行时的单位，堆是存储时的单位。==栈一般存放基本数据类型，和内存中对象的引用类型。

是每个线程在创建时就有的，里面保存的是栈帧（对应一个当前方法）。生命周期和线程一致。

**栈特点**

高效的存储方式，访问速度仅次于程序计数器。

只有两种操作，压栈，弹栈。

不存在垃圾回收问题。但会出现栈溢出异常（栈空间不足）。

**栈帧**

- 栈中的数据是以栈帧形式存储的。栈帧对应一个数据集，包含了当前方法执行的各种信息。
- 在一个活动的线程中，一个时刻内只有一个正在执行的方法，对应当前栈帧，即栈顶栈帧。
- 如果在当前方法中调用了其他方法，新的栈帧会创建出来，压栈，执行当前栈帧。当前栈帧执行结束弹栈，如果有返回值时，会返回给下一个当前栈帧，继续执行。
- 不同线程之间栈帧是独立的，不能互相访问。

**栈帧存储结构**

- 局部变量表
  - 定义为一个数组，存放着局部变量，基本类型和引用类型
  - 以槽（slot）为存储单位，一个slot对应一个下标索引。一个int占一个solt，long，double占两个
  - 大小在编译期就确定了，当局部变量表越大，就会影响栈帧大小，进而影响栈存放的栈帧数目，限制方法嵌套调用的次数。
  - 只在当前方法有效，栈帧弹出，局部变量表也就被销毁。
- 操作数栈
  - 用于保存计算过程中的中间结果，作为计算过程中变量的临时保存空间。
  - 栈结构，每次对栈的操作都对应了字节码的指令。
- 动态链接
  - 每一个栈帧都保存了一个指向运行时常量池或栈帧所属方法的引用
  - 方法调用
    - 静态链接：调用的方法在编译期间可知，且运行期保持不变。对应早期绑定。
    - 动态链接：调用方法在运行期才可知。对应晚期绑定。
  - 非虚方法：编译器确定，运行期不变的方法。静态，私有，final，构造器方法，父类方法都是非虚方法。其他方法为虚方法。
- 方法返回地址：方法退出本质就是栈帧出栈的情况，需要恢复上层栈帧的局部变量表，操作数栈，PC计数器的情况。pc计数器存放在哪，存疑。

### 堆

**概述**

- 一个java程序对应一个jvm实例，一个jvm实例中只有一个堆内存，也是内存管理（GC）核心区域。
- 堆在jvm启动时就被创建，大小可通过jvm参数设置，固定或者可变。
- 多个线程共享一个堆内存。
- 对象实例几乎永远在堆中。对象没有引用时，不会立即被回收，需要等待垃圾回收线程处理。

**分区**

1.7及以前：新生代，老年代，永久代。

1.8：新生代，老年代，元空间。

**对象区域分配**

new出的对象，首先分配在Eden区。如果Eden区空间不够了，虚拟机会进行一次新生代垃圾回收，它会把Eden区中存活的对象放入survivor区，再把new的对象放进新生代。

特殊情况：如果Eden区空间不够了，虚拟机会进行一次minor gc，并把Eden区对象放入survivor区，如果survivor区空间不够了或者次数到达阈值，就直接晋升老年代，然后再在Eden区放置新对象，如果还是空间不够，就放置到老年代，如果老年代也空间不够，虚拟机会进行一次full gc，如果还是空间不够，就报内存溢出错误。

- 策略
  - 新创建的对象首先考虑Eden区。
  - 大对象直接进入老年代
  - 当survivor区同龄的对象所占空间大于survivor区的一半，大于这个年龄的对象进入老年代。

**垃圾回收**

- 部分收集
  - minor gc：针对新生代的垃圾收集，目前仅有CMS收集器有。Eden区满触发minor gc，一般大多数对象都是朝生夕死的，所以minor gc很频繁，一般速度也比较块。
  - major gc：针对老年代的垃圾收集。一般major gc前会先进行minor gc（不是绝对），如果空间还不足就major gc。
  - mixed gc：混合收集，目前仅G1收集器有。
- full gc：整堆收集。当老年代空间不足。方法区空间不足。当新生代晋对象升老年代空间不够。

**频繁full gc的原因**

- 可能是程序中调用了`System.gc()`
- survivor区中的年龄阈值设置过小，导致老年代对象过多。
- 老年代或者方法区空间不足。

**为什么堆要分区**

70%-99%的对象都是临时对象。

分区是为了更好垃圾收集，如果所有对象都在一个区间，那么要区分需要收集的垃圾就比较困难，增加了垃圾收集的时间，使得STW更长，降低效率。

**TLAB**

线程私有分配缓冲区，堆是线程共享的区域。对象创建在多线程环境下，需要对地址进行加锁等机制，影响分配速度。

所以在堆内存中划分出一块每个线程私有的区域，线程优先使用TLAB的内存。

**逃逸分析**

- 当一个对象在方法中定义，它只在方法中使用，就没有发生逃逸。
- 当一个对象在方法中定义，它被外部所调用（如有返回值），就发生逃逸。

对于大多数对象来说，是在堆中分配内存。但如果经过逃逸分析，发现当前这个对象不会发生逃逸，就可以让它在栈中分配。

使用逃逸分析，编译器可以对代码做一些优化

- 栈上分配：如果一个对象不会发生逃逸，那么它就可以在栈上分配内存。
- 锁消除：如果一个锁对象同时只能被一个线程访问，JIT编译器会取消对这个同步块的代码的同步。
- 标量替换：标量即为基本类型，聚合量为标量和其他聚合量组成的类型。如果对象不会发生逃逸，那么JIT会把对象的标量属性拆解为局部变量。

### 方法区

**概述**

尽管方法区在逻辑上属于堆，但一些简单的jvm实现中不会去考虑方法区的垃圾收集。Hotspot虚拟机中方法区有个别名Non-Heap，所以可以看做方法区是与堆分开的。

- 与堆一样，是线程共享的内存区域。
- jvm启动时就会创建，大小可通过jvm参数设置，固定或者可变。
- 方法区大小决定了程序可以保存多少个类，如果加载的类（jar包）太多会造成OOM

**存储内容**

> 类型包括：Class，Interface，Enum，Annotation。

- 类型信息：类型和父类型的全限定名。类型的修饰符。
- 属性信息：类型属性的名称，类型，修饰符。
- 方法信息：方法名称，返回类型，参数数量、类型，修饰符
- non-final static变量，final static常量

**class文件常量池**

java类编译后生成字节码文件，需要数据支持，有些数据很大，或者是引用类型，不能通过字节码表示，所以就有一个常量表，里面有各种数据的符号引用。字节码就通过常量表的符号对数据进行使用。

**运行时常量池**

是方法区的一部分。

java类在加载到内存中时，虚拟机会为该类在方法区创建一个常量池，即把class文件中的常量池的数据放到方法区，并且把其中的符号引用替换为指向数据的实际引用。

**垃圾回收**

方法区主要是存储字面量，符号引用 和 类元数据。

回收字面量和符号引用相对容易，判断有无引用指向它即可。

判断类型是否需要回收就比较麻烦，需要三个条件1. 没有任何该类的对象实例或者其子类的实例。2.加载该类的类加载器已被回收。3.对应的java.lang.Class对象没有任何引用。

### 对象实例化

**创建对象的方式**

- 构造器，new，反射等方式
- clone方法
- 序列化，反序列化
- 第三方库

**创建对象的步骤**

- 判断对象对应的类是否已经被加载，如果没有则需要先进行类加载
- 为对象分配内存
  - 内存规整，指针碰撞，指针指向的是空闲和使用内存的分界线，只是移动一段距离。
  - 不规整，空闲列表，虚拟机维护一个内存列表，记录内存块的使用情况，选择出一个适合大小的块分给对象。
- 分配内存的时候可能会有并发安全问题，可以通过CAS或者TLAB解决。
- 初始化分配的空间，为类变量设置默认值。
- 设置对象头。
- 类构造器方法执行

**对象内存布局**

- 对象头：`Mark Word`：包含对象哈希值，年龄分代，锁标志等。`Klass Word`：指向方法区类元数据的地址。
- 实例数据：程序中定义的各种类型的字段，和从父类继承的字段。

**对象访问定位**

- 直接指针：引用变量直接指向对象地址
- 句柄访问：引用指向句柄，句柄再指向对象。

### 直接内存

堆外，本地内存。

普通java程序在磁盘IO时，需要通过缓存由用户地址向内核地址传输。这样需要拷贝两份数据，效率很低。

直接内存使得java程序直接操作本地内存，直接通过操作系统的缓冲区，写入磁盘。

### 执行引擎

**概述**

是jvm的核心组成部分。它的工作是讲字节码 ==翻译/编译== 为机器码。

**java代码编译执行的过程**

源程序-》词法分析-》单词流-》语法分析-》语法树-》解释器/编译器-》目标代码。

java的字节码可以由上述过程翻译为机器码，通过解释器或者JIT编译器。

### 垃圾回收

- 标记阶段算法

  - 引用计数算法：被引用，计数器就加一，问题：对象之间循环引用时造成内存无法回收。
  - 可达性分析算法：从GCROOT开始搜索，从上至下搜索被根连接的对象，并进行标记。可作为GCROOT的对象：虚拟机栈中的对象、本地方法引用的对象、方法区中静态属性、常量引用的对象、同步依赖的锁对象、虚拟机内部引用（基本数据类型，常驻异常的Class对象）

  > 1. 由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。
  > 2. ==对于标记阶段，要分析垃圾是否能被回收，必须在一个保证一致性的快照中进行。==所以GC时必须要进行停顿，也就是STW。（如枚举根节点时）
  > 3. 在判断为垃圾回收之前需要判断对象是否重写finalize方法，如果未重写或者该方法已经执行过，即代表可以回收；如果该方法未执行过，则该对象可能复活，不能立即回收，而是被放入一个FinalizeQueue，由一个虚拟机的Finalizer线程触发其finalize方法，如果在这其中有GCROOT连接的引用，就移除队列。如果该对象再次失去了引用，那么不会再次调用finalize方法。

- 清除阶段算法

  - 标记-清除算法：收集器会暂停程序，从根节点开始标记对象（设置对象头是否为可达对象），然后对堆内存线性遍历，对没有被标记为可达的对象进行回收。（这里清除是把清除对象的地址放入空闲列表，等待需要的时候使用）
  - 复制算法：将内存空间分为两个区域，活动和空闲区域，每次在活动区域分配内存，当需要垃圾回收时，把活动区域可存活的对象复制到空闲区域，再清空活动区域，然后交换两个区域的身份。
  - 标记-压缩：开始和标记清除算法一样，但是在清除完垃圾后，需要将存活的对象移动到内存的一端

- 垃圾回收器

  > GC性能评价指标
  >
  > ==吞吐量==：CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/ （运行用户代码时间+垃圾收集时间）
  >
  > ==暂停时间==：一个时间段内应用程序线程暂停，让GC线程执行的STW时间。

  - Serial：采用复制算法。主要在新生代，一个线程执行垃圾回收，并且回收时需要SWT，回收结束再执行用户线程。（老年代版本，Serial Old收集器，采用标记整理算法）

  - ParNew：采用复制算法，主要在新生代进行垃圾回收，Serial的多线程版本，在多核CPU下可提高吞吐量。

  - Parallel Scavenge：采用复制算法，==为达到一个可控制的吞吐量，它有自适应调节策略==（老年代版本，Parallel Old，采用标记整理算法）

  - CMS：主要在老年代，采用标记清除算法。尽可能缩短垃圾收集线程暂停用户线程的时间。

    - 初始标记：暂停用户线程，标记GCRoot关联的对象。
    - 并发标记：通过GCRoot标记可达对象，这时不需要暂停用户线程。
    - 重标记：由于并发标记时，用户线程可能改变对象的引用情况，所以需要再次暂停用户线程，再次进行一次标记。
    - 并发清除：清除前面标记的对象，此时不需要暂停用户线程。

    由于比较耗时的并发标记和并发清除阶段都不需要暂停用户线程，所以整体回收过程是==低延迟的==。由于CMS要==并发清除==，它不能等到老年代内存满了再清除，因为要给应用程序留下运行空间，所以在大于阈值时就要进行垃圾收集。如果CMS预留的空间不足，虚拟机会通过备用方案Serial Old收集器进行老年代收集，但是STW时间就很长。

    **CMS弊端：**产生内存碎片，无法处理浮动垃圾。

  最小化使用内存和并行开销：Serial。最大化吞吐量：Parallel。最小化STW时间：CMS。

- G1垃圾回收器

  - 它把堆分为一个一个的区域，并标识每个区域回收的价值（回收的空间与耗时的经验值），维护每个区域的价值列表，优先收集价值大的区域（垃圾优先）。它是多个线程执行，有并发性和并行性。
  - 它依然属于分代型收集，它兼顾年轻代和老年代

### 常用参数

- 设置堆内存初始大小`-Xms`
- 设置堆内存最大值`-Xmx`
- 设置新生代大小`-Xmn`
- 每个线程Stack大小`-Xss`
- 使用指定垃圾回收器。`-XX:+UseSerialGC,-XX:+UseParallelGC,-XX:+UseParNewGC`等。
- 辅助信息`-XX:+PrintGC,-XX:+PrintGCDetails`

### 常用命令

- `jinfo`：可以输出并修改运行时的java 进程的opts。 
- `jps`：与unix上的ps类似，用来显示本地的java进程，可以查看本地运行着几个java程序，并显示他们的进程号。 
- `jstat`：一个极强的监视VM内存工具。可以用来监视VM内存内的各种堆和非堆的大小及其内存使用量。 
- `jmap`：打印出某个java进程（使用pid）内存内的所有'对象'的情况（如：产生那些对象，及其数量）。 
- `jconsole`：一个java GUI监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器VM。

# Java框架

## Mybatis

**初始化**

即创建Configuration对象的过程

可以通过xml配置文件，或者自己编写Configuration类进行配置

- **执行流程**

读取**Mybatis**的xml配置⽂件，构建*Configuration*对象

通过**SqlSessionFactoryBuilder**对象(用完就扔)根据传入的*Configuration*对象创建**SqlSessionFactory**对象(生命周期与应用一致)

获取当前线程的**SqlSession**（线程不安全，每个线程都需要有一个实例）

事务默认开启

通过**SQLSession**读取映射⽂件中的操作编号，从⽽读取**SQL**语句

提交事务

关闭资源

- **SQL执行流程**

加载配置->SQL解析->SQL执行->结果映射->释放连接

- **动态sql**

Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态**sql**，完成逻辑判断和动态拼接**sql**的功能。

Mybatis提供了9种动态sql标签：`trim|where|set|foreach|if|choose|when|otherwise|bind`。

其执行原理为，使⽤OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接**sql**，以此来完成动态**sql**的功能。

- **Mapper接口工作原理**

**JDK**动态代理，**Mybatis**运⾏时会使⽤**JDK**动态代理为**Mapper**接口生成代理**proxy**对象，代理对象**proxy**会拦截接⼝⽅法，转⽽执⾏**MappedStatement**所代表的**sql**，然后将**sql**执⾏结果返回。

## Spring

- Spring是一个开源免费的框架
- 是非侵入式的，轻量级的
- 两个核心部分，IOC和AOP

### **IOC**

对象的控制权交给IOC容器，有它负责对象的创建，装配，管理这些对象的生命周期。

==优点==

- 解耦，最小的代价使松耦合得以实现。
- 托管类的产生过程，用户程序无需关心其具体实现。

==原理==

工厂模式+反射

1. 加载配置文件，生成BeanDefination，加入BeanFactory的Map中
2. 调用getBean时，从Map中拿出BeanDefination，进行实例化。如果有依赖关系，递归调用getBean方法，完成依赖注入。

**依赖注入**

组件之间的依赖关系由系统运行时决定。容器动态的将某种依赖关系的目标对象实例注入到各个关联的组件中。

- 构造函数注入
- set方法注入
- 注解注入
- p名称空间
- 自动装配（了解）

==优势：==不依赖于容器，完全可以在任意容器外的地方使用对象。

**常用注解**

- Autowired：默认按类型查找Bean，可以设置acquire非必须。是第三方Spring注解。
- Resource：默认按name查找Bean，找不到再按类型找。可以设置byName或者byType。是Java原生注解。

**循环依赖**

bean默认情况是单例的。*prototype不支持循环依赖*

```java
public class A{
    private B b;
}
public class B{
    private A a;
}
```

Spring在创建Bean的时候先把对象创建出来，加入到map缓存中，然后再进行属性的注入，当发现属性依赖其他某个Bean时，查找map中是否存在该Bean对象，若存在就把map中的取出，如果不存在就进行创建该Bean，进行递归调用，同前面一样，先把实例放入map，再遍历属性，进行注入，若发现依赖，对于上面情况，此时A的实例已经创建放好在map中，所以B在属性注入时就可以得到。返回A时同理。

Spring内设置了三个map缓存

- *singletonFactories* 创建Bean的原始工厂

- *earlySingletonObjects* 缓存Bean的早起映射，即对于上面B进行属性注入时拿到的A就是早期映射
- *singletonObjects* 真正完成属性注入的Bean缓存，我们拿到的就是这里的。

### Spring Beans

组成Spring应用的主干java对象，它们被IOC容器创建，管理。

给Bean配置元数据

- xml文件
- 注解
- java配置类

生命周期

- IOC容器会通过Bean的定义进行创建，通过反射。
- 然后进行属性的注入，setter方法等。
- 如果Bean实现了一些`XXXAware(BeanNameAware，BeanClassLoaderAware等)`接口，会执行相应接口的方法。
- 如果有和加载这个Bean相关的`BeanPostProcessor`处理对象，执行该对象的`postProcessBeforeInitialization`方法。（前置处理）
- 如果Bean实现了`InitializationBean`接口，就执行接口相应的方法。
- 如果Bean配置定义中有`init-method`属性，执行指定方法。
- 如果有`BeanPostProcessor`则执行该对象方法（后置处理）
- 销毁Bean时，如果Bean实现了`DisposableBean`接口，则执行`Destory`方法。
- 销毁Bean时，如果Bean中有`destory-mothod`属性，执行指定方法。

**BeanFactory**

spring容器基础接口，读取spring配置文件，提供了IOC容器对bean加载实例化，及bean之间依赖关系管理的规范。下面有具体的实现，如xmlBeanFactory，ClassPathXmlApplicationContext等。

- BeanFactory与ApplicationContext区别：BeanFactory在容器初始化后未实例化bean，它在bean被访问时才初始化。ApplicationContext在容器初始化时会把所有的bean都初始化。

**FactoryBean**

一个接口，实现该接口的类就会成为一个特殊的Bean，我们从容器中通过bean id获取的是该类中`getObject`方法返回的对象。这个接口使得容器在创建bean时可以进行一些化简或者增添一些功能。

**Bean生命周期**

![image-20200811214033714](面试题整理.assets/image-20200811214033714.png)

**Bean自身的方法**：如调用 Bean 构造函数实例化 Bean，调用Setter 设置 Bean 的属性值以及通过的` init-method` 和 `destroy-method` 所指定的方法；

**Bean级生命周期接口方法**：如 BeanNameAware、 BeanFactoryAware、 InitializingBean 和DisposableBean，这些接k口方法由 Bean 类直接实现；

**容器级生命周期接口方法**：在上图中带“★”的步骤是由 InstantiationAwareBean和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。 后处理器接口一般不由Bean 本身实现，它们独立于 Bean，实现类以容器附加装置的形式注册到Spring容器中并通过接口反射为Spring容器预先识别。当Spring 容器创建任何 Bean 的时候，这些后处理器都会发生作用，所以这些后处理器的影响是全局性的。当然，用户可以通过合理地编写后处理器，让其仅对感兴趣Bean 进行加工处理

![image-20200811213830206](面试题整理.assets/image-20200811213830206.png)

### AOP

把与业务无关的一些任务（如事务管理，日志，权限控制等）封装起来，在不增加耦合度的情况对已有功能进行拓展。

- 原理：动态代理。有接口就用JDK动态代理，无接口就用`cglib`代理(cglib被代理的类不能是final)。
- JDK代理：被代理类实现一个接口，代理类内置一个被代理的对象，代理类通过Proxy类的new Instance方法返回一个代理对象，这个方法需要被代理对象的类加载器，实现的接口，以及一个调用处理器（通过实现接口或者匿名内部类创建`InvocationHandler`）。在用户通过代理对象调用目标对象方法时，处理器就发生作用，在执行被代理对象方法之前或之后，进行一些其他公有的操作，如日志记录等。
- cglib代理：代理类需要实现`MethodInceptor`接口，在返回代理对象时通过`Enhancer`对象，设置目标对象为其父类，`setCallBack`为当前代理类。并重写`intercept`方法，在这个方法中添加需要的额外操作。

Spring的AOP就是把业务对象和关注点对象`(功能重复的代码提取)`分离。

> 把关注点功能抽象为一个类，叫做切面（类）。
>
> 业务对象的方法称为切入点。
>
> 在业务对象方法执行的前后添加关注点功能，叫通知。
>
> 切入点可以设置表达式，指定要求的包，类，中的方法进行通知。

### 事务

**编程式事务管理**

通过 `TransactionTemplate`或者`TransactionManager`手动管理事务。

**声明式事务管理**

通过AOP实现（Transactional注解使用最多）

- 事务管理接口

**`PlatformTransactionManager`**事务管理器，spring事务管理核心。**事务的管理者**

**`TransactionDefinition`**事务定义信息，隔离级别，传播行为等。**`TransactionStatus`**事务运行状态。**这两个都是事务描述信息**。

### 事务传播行为

```java
Class A {
    @Transactional(propagation = Propagation.REQUIRED)
    public void aMethod {
        //do something
        B b = new B();
        b.bMethod();
    }
}

Class B {
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void bMethod {
       //do something
    }
}
```



#### **REQUIRED**

如果当前存在事务就加入，不存在就创建一个事务。

如果a方法没有设置required，b方法设置了，b方法自己的事务与a的事务独立，互不干扰。

如果a方法，b方法都设置了required，它们就属于同一事务，回滚时所有操作都回滚。

#### **REQUIRES_NEW**

创建一个新的事务，如果当前已经有事务，把当前事务挂起。和创建的事务互不干扰。

如果a方法设置了required，b方法设置requires_new，b方法的事务就和a独立了，即使a发生错误回滚，b不会回滚。

但是b如果抛出异常，a，b事务都会回滚。

#### **NESTED**

如果当前有事务，创建一个子事务。如果当前没有事务和REQUIRE作用相同。

如果a方法设置了required，b方法设置了nested，如果a的事务回滚，b也会回滚。b的事务回滚时不影响a的事务。

#### MANDATORY

如果当前存在事务，就加入，如果不存在就抛出异常。

#### 其他传播行为

- **PROPAGATION.SUPPORTS**: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
- **PROPAGATION.NOT_SUPPORTED**: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。
- **PROPAGATION.NEVER**: 以非事务方式运行，如果当前存在事务，则抛出异常。

## SpringMVC

**请求流程**

- 浏览器请求到DispatcherServlet。
- DispatcherServlet根据请求调用HandlerMapping。
- HandlerMapping解析出Handler，调用HandlerAdapter。
- HandlerAdapter调用具体Controller处理业务逻辑。
- Controller处理完返回一个ModelAndView对象给DispatcherServlet
- DispatcherServlet发给ViewResolveor，解析Model（数据），View（视图）
- 最后DispatcherServlet返回给浏览器View。

## SpringBoot

**开箱即用**

springboot项目在pom依赖中会包含父工程依赖，其中会包含springboot的一些指定版本号的核心依赖，我们在导入一些springboot依赖时可以不指定版本号。

**启动器**

就是一个场景依赖的集合，项目需要某些功能时，添加这个功能的启动器，springboot就会吧这个场景需要的所有依赖都导入，不需要我们逐个导入jar包。

**自动配置原理**

springboot启动程序有个`SpringBootApplication`注解，里面有两个核心注解，一个是`SpringBootConfiguration`，它就是一个的`Configuration`注解，另一个是`EnableAutoConfiguration`注解，它里面包含了自动导包注解`AutoConfigurationPackage`和一个导入依赖的注解`Import`。`Import`指定了一个类`AutoConfigurationImportSelector`，这个类会去获取候选的依赖配置，通过类`SpringFactoriesLoader` ，它会到`AutonConfigure`包下的`spring.factory`文件中确定候选配置类的位置，然后加载候选的配置类到IOC容器。

候选的配置类不是所有都会加载，这些配置类上有一个`ConditonOnXXX`注解，里面包含了加载这个配置类的条件，当所有条件都满足时，spring才会去加载。

**跨域请求CORS**

CORS即跨域资源共享。以前的协议为了安全问题是有同源策略限制的，即不同域名，同域名不同端口是不能互相访问请求资源的。而实际应用中需要跨域访问是通过JSONP来进行，但它只支持get方法。CORS是一个W3C标准，它是一个浏览器技术规范，提供了web服务器从不同网域传来沙盒脚本的方法，避开了浏览器同源策略。

Springboot中可以使用CrossOrigin注解来配置跨域请求，也可以设置全局配置类设置。

**CSRF**

跨域请求伪造。当用户离开页面时，如果有其他恶意网站在某个链接写上服务器的域名下某个路径，如果用户登录还未过期，那么这个跨域请求就能模拟用户操作，造成损失。

浏览器在实际操作中会把请求分为几类，简单请求，预先请求，带凭证请求等。预先请求会先发送一个options探测请求，和浏览器协商是否接收请求。默认跨域请求不需要凭证，服务器可以设置要求客户端凭证，以避免跨域伪造攻击。

# 操作系统

## 计算机组成部分

**存储器：**主存，内存。

**运算器，控制器：**共同组成CPU

**输入输出设备：**与用户进行交互，展示计算机的运行信息，获取外部输入信息。

## 进程和线程

**进程：**是运行程序的一个实例，操作系统分配资源的基本单位。一般包含程地址空间，全局变量，子进程，打开文件，信号处理程序等。对于一个CPU来说，一个时刻只能运行一个程序，只不过以秒为单位，CPU在切换进程执行的速度很快，让人有一种并行的错觉。

**进程的状态**

- 创建，

- 就绪，进程进入就绪队列，等待CPU的调度。
- 运行，进程正在被CPU执行，即占用CPU时间片。
- 阻塞，进程发生某事件（IO请求等）不能继续执行，CPU会把时间片分给其他就绪状态的进程，受阻的进程就处于暂停状态。

**线程：**是进程中的一个控制流，是CPU调度的最小单位。一个进程中可有多个线程，分别执行不同的任务。一般包含程序计数器，堆栈，寄存器等。

**进程间通信**

- 信号：是Unix系统最先使用的进程间通信的方式。可以向一个进程或多个进程发送信号，可以通过键盘输入，或者shell命令发出。接收信号的进程如果有信号处理程序，就执行。也可以选择不处理，交给内核处理，执行默认处理。
- 匿名管道：匿名管道实际上是存在于内存中的一种特殊的文件系统。它类似于一个先进先出的队列。匿名管道数据只能单向流动。数据只能在管道一端写入，另一端读取。只有管道的读端存在时，写端才有意义，否则写数据的进程将会收到内核传来的信号，进程可以处理该信号也可以忽略（默认动作时进程终止）。匿名管道通信的双方必须是具有亲缘关系的两个进程(父子进程或兄弟进程)。同时，由于管道传递的是字节流，通信的双方必须约定好信息的格式。
- 命名管道：命名管道的数据可以单向或双向流动。它可以支持一台主机上任意两个进程间通信。这是因为命名管道是一个存在于磁盘或者文件系统上的文件，它提供了一个路径名，可以让所有进程都能找到。命名管道严格遵循先进先出的规则，总是从文件头读取数据，而把数据写到文件尾，不支持文件定位的操作。
- 消息队列：消息队列是存在于系统内核中的消息链表，只有当内核重启或者显式关闭时消息队列才会被关闭。这样做的好处是让消息队列独立于通信的进程而存在。与管道相比，消除了同步打开的困难。消息队列传递的数据都是一个个的消息块，消息块可以有格式，消除了管道字节流通信的困难。消息队列可以同时给多个进程通信。同时因为消息队列是独立于通信进程的，所以写端写数据时，允许另一端没有接收消息的读端。
- 共享内存：两个或多个进程可以共同使用一块内存，对其中的修改所有进程可见，相当于进行了通信。
  - 对于内存中的共享资源，需要进行约束，就有了信号量机制，p操作消耗资源，v操作归还资源。在没有资源时进程不能进行操作。
- 套接字：通过网络传输协议tcp，udp传输信息。



## 文件描述符



## IO与阻塞

**阻塞IO**：是指用户进程发起一个IO系统调用，从内核缓存到用户进程内存需要时间，这时当前线程会被挂起等待。

**非阻塞IO**：是指用户进程发起IO系统调用时，如果内核中的数据没有准备好，它不会阻塞用户进程，而是给其返回一个error。用户进程就轮询看内核中的数据是否准备好。

**IO多路复用**

select，poll，epoll。让进程可以同时处理多个网络连接的IO。基本原理是select/epoll会不断轮询所负责的所有socket，当某个socket的数据到达了，就通知用户进程。

当用户进程调用了select，用户进程就会被挂起，内核会监视所有select负责的socket，当socket的数据好了，就通知用户进程调用read从内核中读取数据到用户内存。

它其实和阻塞IO没有太大不同，IO多路复用的主要作用是处理多个连接。

> - select：单个进程能监视的文件描述符(进行IO的操作)存在限制，一般Linux最大为1024，可以通过修改宏定义提升这个限制。但是会造成效率降低。
> - epoll：在内核中会维护一个红黑树和双向链表，红黑树存放事件，双向链表存放就绪的事件，所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，相应事件发生时会调用这个回调方法（在内核中这个方法叫`ep_poll_callback`），它会将发生的事件添加到双向链表。epoll没有最大连接数限制。
>
> select适合少量活跃的链接，一般几千；epoll适合大量不活跃的链接。

==阻塞IO，非阻塞IO，IO多路复用都属于同步IO，因为它们在从内核中拷贝数据到用户进程内存中需要阻塞用户进程。==

**异步IO**：当一个异步过程调用发出后，调用者不能立刻得到返回结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。



## 进程表

操作系统为了跟踪每个进程的活动状态，维护了一个进程表。在进程表的内部，列出了每个进程的状态以及每个进程使用的资源等。

## 僵尸进程

僵尸进程：一个子进程在其父进程还没有调用wait()或waitpid()的情况下退出。这个子进程就是僵尸进程。

> 进程一旦调用了wait，就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。

任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是每个子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。

## 孤儿进程

父进程退出后，子进程依然在运行

## 调度算法

**批处理调度**

- 先来先服务：操作系统在就绪队列中选择队首（最先进入的）线程，进行执行，它不会限制进程执行的时间。如果进程阻塞，就选择队首进程继续执行，被阻塞的进程排到就绪队列尾部，等待执行。如果一个阻塞的线程恢复到就绪状态，会加入到队列尾部，等待执行。这种算法的缺点是如果有一个长进程长时间占有处理机，则队列里其它进程就会一直得不到调度。
- 最短作业优先：从就绪队列中选择一个预估时间最短的进程执行。对长进程不友好。
- 剩余时间最短优先：选择一个剩余时间最短的执行。

**交互调度**

- 轮询调度：为每个进程分配一个时间片，若进程未执行完毕时间片结束，则加入队尾，继续执行队首进程。
- 优先级调度：每个进程有一个优先级，优先级高的先执行。

## 银行家算法

进程请求资源时，操作系统会做判断

1. 如果请求的资源大于该进程所需的最大资源，就回绝，否则第二步。
2. 操作系统检查该进程请求的资源是否大于系统已有资源的数量，是则回绝，否则第三步。
3. 操作系统分配资源之前会执行安全算法，如果返回true，就分配资源，否则回绝。

**安全算法：**操作系统会从所有未执行完的线程中选择一个满足条件的`这个进程所占有的资源加上操作系统当前剩余的资源大于等于这个进程所需的最大资源`，如果满足要求，就把该进程占有的资源算到系统的资源里面。然后再查看其它进程，如果所有进程都满足了要求，则会有一个安全序列，满足安全序列的资源分配就是安全的。

## 内存

**内存交换**

在多个进程执行时，内存不够时会把空闲进程放入磁盘，等内存足够时在把进程拿出来。这个过程可能会导致进程前后两次在内存中的地址不一样，这个由基址寄存器（存储数据内存的起始位置）和变址寄存器（存储应用程序长度）实现重定位。

**空闲内存管理**

位图

空闲列表

**内存分段管理**

将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。

**内存分页管理**

将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的页框，程序加载时，可以将任意一页放入内存中任意一个页框，这些页框不必连续，从而实现了离散分离。

**虚拟内存**

虚拟内存是内存管理的一种技术。应用程序按页装载进内存，当内存不够时，它会把内存中不常用的页复制到磁盘，把空间让出来给当前程序用。

它让应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分甚至不在内存中，而是在磁盘存储器上，在需要时进行数据交换。

**内存分页**

建立虚拟内存与物理内存的映射，使得虚拟地址是连续的，物理地址可以不连续。

分页实现：把物理内存分为一个个页（叫页帧），虚拟内存也分为一个个同大小的页（叫页面）。当进程需要执行时，把需要的数据页从文件系统加载到物理内存。

页作为最小的映射单位，通常一页是4096个字节(4KB)。有一个虚拟页映射到物理内存页的表，CPU会通过虚拟页号找到对应的物理页号，通过页大小计算出页帧偏移，然后通过数据行计算出页内偏移。

- 这样的好处：虚拟地址独立于物理地址，程序运行时地址空间隔离。
- 不会有外部碎片（但因为是以页帧为单位，会有内部碎片）
- 分页粒度小，使内存使用率更高，在进程执行时可以将不需要的内存页换入磁盘，把需要的内存页换出使用。

## 页面置换算法

**理想置换算法：**去除以后不再需要的页面，如果不存在这样的页面，移除未来最长时间不需要访问的页面。因为未来不可知，所以是理想算法。

**FIFO** **替换内存中驻留时间最长的**。操作系统维护一个内存页面链表，从链表顺序看，队首的元素驻留时间最长，缺页时替换掉队首页面。

**LRU：**替换掉到目前为止最久没有使用的页面。当访问某个内存页面时，操作系统会把该页放置到队首，有新增页面页加到队首。当发生缺页时替换掉队尾的页面。

**LFU：**如果一个数据在最近一段时间很少被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，**最小频率访问的数据最先被淘汰**。

## DMA

DMA 即直接内存访问，它意味着 CPU 授予 I/O 模块权限在不涉及 CPU 的情况下读取或写入内存。也就是 DMA 可以不需要 CPU 的参与。这个过程由称为 DMA 控制器（DMAC）的芯片管理。

由于 DMA 设备可以直接在内存之间传输数据，而不是使用 CPU 作为中介，因此可以缓解总线上的拥塞。DMA 通过允许 CPU 执行任务，同时 DMA 系统通过系统和内存总线传输数据来提高系统并发性。

> 传统文件传输的性能非常糟糕。
>
> 1. 应用程序调用read读取文件。(从用户态转换为内核态)
> 2. 然后通过DMA把磁盘文件的内容拷贝到内核缓冲区，然后再拷贝到内存。(内核态切换回用户态)
> 3. 然后程序调用write方法，把内存的数据拷贝到socket缓冲区中。(用户态切换为内核态)
> 4. 然后通过DMA把socket缓冲区的数据拷贝到网卡。(内核完成任务，切回用户态)
>
> 这个过程有四次数据拷贝和四次用户态与内核态的上下文切换，效率很低。

**减少上下文切换和数据拷贝的次数**

- mmap
  mmap会把内核缓冲区的数据映射到用户空间，就免去了一次内核缓冲区到用户空间的拷贝。
- sendfile
  Linux内核版本2.1中提供了一个专门发送文件的函数(是系统调用函数)，它可以把内核缓冲区中的数据直接拷贝到socket缓冲区，免去通过用户空间的拷贝。

但sendfile还不是真正的零拷贝技术，还需要网卡是否支持`scatter-gather`的特性，Linux可通过以下命令查看。

```bash
$ ethtool -k eth0 | grep scatter-gather
scatter-gather: on
```

Linux从内核版本2.4开始，对于网卡支持`SG-DMA`技术的情况，sendfile系统调用的过程发生了变化。

- 通过DMA把磁盘的数据读到内核缓冲区。
- 缓冲区的数据描述符和数据长度传到socket缓冲区。网卡的`SG-DMA`控制器直接把内核缓冲区的数据拷贝到网卡中。

这就是所谓零拷贝技术，即没有在内存层面拷贝数据，即全程没有cpu参与，全通过DMA进行传输。

## 缓存

**CPU高速缓存**

由于CPU执行指令的速度很快，从内存直接读取的速度跟不上，所以在内存和CPU之间就有了一个缓存，它的读取速度很快，在程序执行时，操作系统会先将指令放入高速缓存，然后CPU取，当CPU在缓存中读不到时再去内存中读取。这样避免了CPU频繁的读取内存，提高了执行效率

**磁盘高速缓存(PageCache)**

零拷贝技术用到了`PageCache`，它的作用就是缓存最近被访问的数据，读取数据时优先在缓存中找。由于读取磁盘数据需要磁头旋转到数据对应的扇区，所以`PageCache`使用了预读功能：假设read每次只读32KB，但内核会把后面的`32~64KB`的数据读到`PageCache`，这样后面读取这部分数据的成本就很低。

但是针对大文件(GB)时，`PageCache`的作用就没用了，缓存空间是比较小的，大文件很快就会沾满它，文件过大访问局部性的概率就很低，反而还需要DMA再从`PageCache`拷贝，读写性能反而下降。

作用类似于CPU缓存，解决了总线接口的高速需求和读写磁盘的矛盾。

## PCB

进程控制块: 是操作系统管理控制进程运行的信息集合，操作系统用PCB来描述进程的基本情况以及运行变化的过程,PCB是进程存在的唯一标志。

- 进程的创建：为进程创建PCB
- 进程的终止： 回收他的PCB
- 进程的组织管理：通过对PCB的阻值管理实现

## 文件

在Linux文件系统中，不论什么类型的文件都会给它分配一个编号，这个编号被称为索引节点编号。它是文件或目录在文件系统中的唯一标识。文件的实际数据在数据区域。

**硬链接**

Linux系统中，多个文件名指向一个索引节点是允许的，这种就成为硬链接。

硬链接允许一个文件拥有多个路径名

**软链接**

就是一个普通文件，只不过里面存放的是另一文件的路径名，通过这个可以快速定位到源文件实体。

## 用户态内核态

**内核态：**内核是一种特殊的软件程序，控制计算机硬件资源，比如CPU调度，内存资源。

**用户态**：是我们应用程序运行的环境，应用程序消耗内存，进行IO需要通过内核。内核为用户提供了一些通用的访问接口，叫做系统调用。

## Linux

### 常用命令

> ### whereis

whereis命令用于搜索程序的二进制文件，源代码文件或帮助文档。

> ### find 

- 在指定目录下查找指定后辍名称文件。`find Test2 -name "*.txt"`，在目录Test2下查找后辍名为.txt的文件。

  `-iname`忽略文件名大小写。

- 查找最近15天修改过的文件。`find  -ctime 15`，查找最近15天修改过的文件。

- 查找文件大小大于20M的文件。`find  -size +20M`，查找文件大小大于20M的文件。

> ### free

- -b 根据bit
- -k 根据kb
- -m 根据mb

查看系统内存情况

> ### grep

**查看进程过滤**

`ps -ef|grep redis`查看redis相关进程。

`ps -ef|grep redis |grep -v auto`查询同时过滤掉某些不相关信息，比如进程信息包含auto的。

`ps -ef|grep redis -c`统计数量

netstat -a 列出所有端口

netstat -at 列出所有tcp端口

netstat -au 列出所有udp端口

netstat -s 显示所有端口的统计信息 

**文件内容搜索**

`grep -n "test" /home/a.md`查找a.md文件中的test字符串，加上`-n`可显示行号。

` grep -n "test" *.md`搜索多个文件中的test字符串。

`grep -rn "test" --exclude=*.txt`搜索时排除指定文件。

`grep -C 5 "foo" file`  显示file文件中匹配foo字串那行以及上下5行

`grep -B 5 "foo" file`  显示foo及前5行

`grep -A 5 "foo" file`  显示foo及后5行

**查找包含指定关键字的文件**

`grep -rn "int main(void)"`查找包含`int main(void)`的文件。

`grep -rLn "int main(void)"`查找不包含指定关键字的文件。

`grep -rni "int main(void)"`查找时忽略大小写。

- -v #显示不包含匹配关键字的所有行。
- -l #显示包含匹配关键字的文件
- -L #显示不包含匹配关键字的文件
- -r #递归搜索
- -i #忽略大小写
- -n #显示关键字所在行号
- -A n #显示关键字后n行
- -B n #显示关键字前n行
- --exclude #搜索时排除某些文件
- --exclude-dir #搜索时排除某些目录
- -f #指定规则文件进行搜索

> ### top

实时显示 process 的动态。

***

**BASH和DOS区别**

1、BASH命令区分大小写，而DOS命令则不区分;

2、在BASH下，/ character是目录分隔符，\作为转义字符。在DOS下，/用作命令参数分隔符，\是目录分隔符；

3、DOS遵循命名文件中的约定，即8个字符的文件名后跟一个点，扩展名为3个字符。BASH没有遵循这样的惯例。

# Git

是目前最先进的分布式版本控制系统。

**SVN与Git区别**

SVN是集中式的，需要先从中央服务器获取项目，下载到本地工作空间，修改完后push到服务器。

Git是在本地创建一个仓库，提交时先在缓存区，然后push到远程仓库。

**Git各部分**

- 工作区：进行代码编辑的文件夹。里面有一个隐藏目录`.git`。
- 版本库：工作区的`.git`目录不属于工作区，这是版本库，里面存放了很多东西，其中最重要的是暂存区`stage`。Git会为我们自动创建分支`master`，和一个指向其的指针`HEAD`。

git add 其实就是把文件添加到暂存区。git commit就是提交更改，把缓存区的内容提交到当前分支上。

```bash
git branch dev #切换分支
git checkout dev #创建并切换分支
git merge dev #合并dev分支与当前分支
git branch –d name #删除分支
```

# 算法

## 快速排序

```java
public void quickSort(int[] arr, int left, int right) {
    if (arr == null || left < 0) {
        return;
    }
    if (left < right) {
        int pivot = partition(arr, left, right);
        quickSort(arr, left, pivot - 1);
        quickSort(arr, pivot + 1, right);
    }
}

private int partition(int[] nums, int low, int high) {
    randomPivot(nums, low, high);
    int pivot = nums[low];
    while (low < high) {
        while (low < high && nums[high] >= pivot) high--;
        nums[low] = nums[high];
        while (low < high && nums[low] <= pivot) low++;
        nums[high] = nums[low];
    }
    nums[low] = pivot;
    return low;
}

/**
 * 随机选取支点
 */
private void randomPivot(int[] nums, int low, int high) {
    int pivot = (int) (Math.random() % (high - low + 1) + low);
    swap(nums, pivot, low);
}

private void swap(int[] arr, int a, int b) {
    int t = arr[a];
    arr[a] = arr[b];
    arr[b] = t;
}
```

## 归并排序

```java
void mergeArray(int[] arr, int left, int mid, int right, int[] temp) {
    //[left,mid],[mid+1,right]的下标指针
    int i = left, j = mid + 1;
    //temp下标
    int idx = left;
    //把这两段有序地放入temp
    while (i <= mid && j <= right) {
        if (arr[i] > arr[j]) temp[idx++] = arr[j++];
        else temp[idx++] = arr[i++];
    }
    //若有剩余
    while (i <= mid) temp[idx++] = arr[i++];

    while (j <= right) temp[idx++] = arr[j++];
    //把排序好的temp放回a
    System.arraycopy(temp, left, arr, left, right - left + 1);
}

void mergeSort(int[] arr, int left, int right, int[] temp) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid, temp);
        mergeSort(arr, mid + 1, right, temp);
        //优化策略，两段有序不再进行合并
        if (arr[mid] > arr[mid + 1]) 
            mergeArray(arr, left, mid, right, temp);
    }
}

void mergeSort(int[] arr, int[] temp) {
    mergeSort(arr, 0, arr.length - 1, temp);
}
```

## 堆排序

```java
public class HeapSort {

    public static void main(String[] args) {
        int[] arr = {7, 6, 7, 11, 5, 12, 3, 0, 1};
        System.out.println("之前：" + Arrays.toString(arr));
        heapSort(arr);
        System.out.println("升序：" + Arrays.toString(arr));
    }

    public static void heapSort(int[] arr) {
        //从最后一个非叶节点开始，构建大根堆
        for (int i = arr.length / 2 - 1; i >= 0; i--) {
            adjustHeap(arr, i, arr.length);
        }

        for (int j = arr.length - 1; j >= 0; j--) {
            //每次把最大值放到数组尾部
            swap(arr, 0, j);
            //重新构建[0,j]区间的大根堆
            adjustHeap(arr, 0, j);
        }
    }

    private static void adjustHeap(int[] arr, int idx, int end) {
        //待调整的值
        int temp = arr[idx];
        for (int i = idx * 2 + 1; i < end; i = i * 2 + 1) {
            //i指向idx子节点中较大的(若是小根堆就指向小的)
            if (i + 1 < end && arr[i] < arr[i + 1]) i++;
            //若子节点大，子节点上浮(小根堆就小的上浮)
            if (arr[i] > temp) {
                arr[idx] = arr[i];
                idx = i;
            } else break;
        }
        //当前idx指向的节点位置满足temp存放
        //即叶子节点，或子节点都小于temp
        arr[idx] = temp;
    }

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```



## 用 Rand7() 实现 Rand10()

```java
public int rand10() {
    int row, col, idx;
    do {
        row = rand7();
        col = rand7();
        idx = col + (row - 1) * 7;
    } while (idx > 40);
    return 1 + (idx - 1) % 10;
}
```



## 把数组排成最小的数

```java
public String minNumber(int[] nums) {
    List<String> list = new ArrayList<>();
    for (int num : nums) {
        list.add(String.valueOf(num));
    }
    list.sort((str1, str2) -> (str1 + str2).compareTo(str2 + str1));
    StringBuilder sb = new StringBuilder();
    for (String s : list) sb.append(s);
    return sb.toString();
}
```

## DFS二叉树迭代遍历

### 通用

```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    Deque<TreeNode> stack = new LinkedList<>();
    if(root != null){
        stack.push(root);
    }
    while(!stack.isEmpty()){
        TreeNode cur = stack.pop();
        if(cur != null){
            //这里是后序遍历左，右，根，
            //由于最后处理根，则需要最先入栈
            stack.push(cur);
            //cur后空结点随之入栈，标识已经访问过，但还没有被处理（还可以进行额外操作）
            stack.push(null);
            //根据前中后顺序的不同，改变cur，left，righ的入栈顺序即可
            if(cur.right != null)
                stack.push(cur.right);
            if(cur.left != null)
                stack.push(cur.left);    
        }else{
            res.add(stack.pop().val);
        }
    }
    return res;
}
```

### 普通

```java
//前序遍历
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> res = new LinkedList<>();
    if(root == null) return res;
    Deque<TreeNode> stack = new LinkedList<>();
    stack.push(root);
    while(!stack.isEmpty()){
        TreeNode n = stack.pop();
        res.add(n.val);
        if(n.right != null)stack.push(n.right);
        if(n.left != null)stack.push(n.left); 
    }
    return res;
}

//中序遍历
public List <Integer> inorderTraversal(TreeNode root) {
    List <Integer> res = new ArrayList<>();
    Stack <TreeNode> stack = new Stack<>();
    TreeNode curr = root;
    while (curr != null || !stack.isEmpty()) {
        while (curr != null) {
            stack.push(curr);
            curr = curr.left;
        }
        curr = stack.pop();
        res.add(curr.val);
        curr = curr.right;
    }
    return res;
}
//后序遍历：前序顺序反向添加
public List<Integer> postorderTraversal(TreeNode root) {
    Deque<TreeNode> stack = new LinkedList<>();
    LinkedList<Integer> output = new LinkedList<>();
    if (root == null) return output;
    stack.add(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        output.addFirst(node.val);
        if(node.left != null) stack.push(node.left);
        if(node.right != null) stack.push(node.right);
    }
    return output;
}
```

### 框架

```java
//前序
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> res = new LinkedList<>();
    if(root == null)return res;
    Deque<TreeNode> stack = new LinkedList<>();
    TreeNode cur = root;
    while(cur != null || !stack.isEmpty()){
        if(cur != null){
            res.add(cur.val);
            stack.push(cur.right);
            cur = cur.left;
        }else{ 
            cur = stack.pop();
        }
    }
    return res;
}
//中序
public List<Integer> inorderTraversal(TreeNode root) {
    Deque<TreeNode> stack = new LinkedList<>();
    List<Integer> list = new LinkedList<>();
    if(root == null) return list;
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        if (cur != null) {
            stack.push(cur);
            cur = cur.left;
        }else{
            cur = stack.pop();
            list.add(cur.val);
            cur = cur.right;
        }
    }
    return list;
}
//后序
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> res = new LinkedList<>();
    Deque<TreeNode> stack = new LinkedList<>();
    TreeNode cur = root, pre = null;
    while(cur != null || !stack.isEmpty()) {
        if(cur != null) {
            stack.push(cur);
            cur = cur.left;
        }else{
            cur = stack.peek();
            // 右孩子为空或者访问过了
            if (cur.right == null || cur.right == pre) { 
                res.add(cur.val); 
                stack.pop();
                pre = cur;
                cur = null; 
            } else cur = cur.right;
        }
    }
    return res;
}
```

### 莫里斯

- 当前节点有左孩子
  - 查看左子树的最右节点是否指向自己
    - 无指向，把最右节点的右指针指向自己
    - 指向，把最右节点的右指针置空
- 当前节点无左孩子
  - 查看右孩子

```java
//先序
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<>();
    if(root == null) return list;
    TreeNode cur = root;
    while (cur != null) {
      if(cur.left != null){
        TreeNode subRight = cur.left;
        while(subRight.right != null && subRight.right != cur){
          subRight = subRight.right;
        }
        if(subRight.right == null){
          subRight.right = cur;
          list.add(cur.val);
          cur = cur.left;
          continue;
        }else subRight.right = null;
      }else if(cur.left == null)
        list.add(cur.val);
      cur = cur.right;
    }
    return list;
 }
//中序遍历
public List<Integer> inorderTraversal(TreeNode root) {
  List<Integer> list = new ArrayList<>();
  if (root == null) return list;
  TreeNode cur = root;
  while (cur != null) {
     if (cur.left != null) {
        TreeNode subRight = cur.left;
        while (subRight.right != null && subRight.right != cur) {
           subRight = subRight.right;
        }
        if (subRight.right == null) {
           subRight.right = cur;
           cur = cur.left;
           continue;
        } else subRight.right = null;
     }
     list.add(cur.val);
     cur = cur.right;
  }
  return list;
}
```



## 最长公共子序列

```java
public int longestCommonSubsequence(String text1, String text2) {
    int len1 = text1.length();
    int len2 = text2.length();
    int[][] dp = new int[len1 + 1][len2 + 1];
    for(int i = 1; i <= text1.length(); i++){
        for(int j = 1; j <= text2.length(); j++){
            if(text1.charAt(i - 1) != text2.charAt(j - 1)){
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }else{
                dp[i][j] = dp[i - 1][j - 1] + 1;
            }
        }
    }
    return dp[len1][len2];
}
```

## 最长上升子序列

```java
 public int lengthOfLIS(int[] nums) {
    int len = nums.length;
    if(len == 0)
        return 0;
    int res = 1;
    int[] dp = new int[len];
    Arrays.fill(dp, 1);
    for(int i = 1; i < len; i++){
        for(int j = 0; j < i; j++){
            if(nums[i] > nums[j])
                dp[i] = Math.max(dp[i], dp[j] + 1);
        }
        res = Math.max(res, dp[i]);
    }
    return res;  
}
```

## 合并区间

```java
public int[][] merge(int[][] intervals) {
    int len = intervals.length;
    if(len < 1){
        return new int[][]{};
    }
    Arrays.sort(intervals, Comparator.comparingInt(in -> in[0]));
    List<int[]> res = new ArrayList<>();
    res.add(intervals[0]);
    for(int i = 1; i < len; i++){
        int[] preInter = res.get(res.size() - 1);
        int[] curInter = intervals[i];
        if(preInter[1] < curInter[0]){
            res.add(intervals[i]);
        }else{
            preInter[1] = Math.max(preInter[1], curInter[1]);
        }
    }
    return res.toArray(new int[res.size()][]);
}
```

## 乘积最大子数组

```java
class Solution {
    public int maxProduct(int[] nums) {
        int max=Integer.MIN_VALUE;
        int[] dpMax = new int[nums.length];
        int[] dpMin = new int[nums.length];
        dpMax[0] = nums[0];
        dpMin[0] = nums[0];
        for(int i = 1;i < nums.length;i++){
            if(nums[i] < 0){
                dpMin[i] = Math.min(dpMax[i-1] * nums[i], nums[i]);
                dpMax[i] = Math.max(dpMin[i-1] * nums[i], nums[i]);
            }else{
                dpMin[i] = Math.min(dpMin[i-1] * nums[i], nums[i]);
                dpMax[i] = Math.max(dpMax[i-1] * nums[i], nums[i]);
            }
            max = Math.max(max, dpMax[i]);
        }
        return Math.max(max, dpMax[0]);
    }
}
```

## 平方根

```java
public int mySqrt(int x) {
    if(x == 0) return 0;
    int left = 1, right = x / 2;
    int res = 1;
    while(left <= right){
        int mid = left + (right - left) / 2;
        if((long)mid * mid <= x){
            left = mid + 1;
            res = mid;
        }else {
            right = mid - 1;
        }
    }
    return res;
}
```

## 连续子数组的最大和

```java
public int maxSubArray(int[] array) {
    int len = array.length;
    int[] dp = new int[len];
    int res = array[0];
    dp[0] = array[0];
    for(int i = 1; i < len; i++){
        if(dp[i - 1] <= 0){
            dp[i] = array[i];
        }else{
            dp[i] = dp[i - 1] + array[i];
        }
        res = Math.max(res, dp[i]);
    }
    return res;
}
```

## 买股票

```java
//限制一次
public int maxProfit(int[] prices) {
    if(prices.length == 0){
        return 0;
    }
    int[] dp = new int[prices.length];
    int min = prices[0];
    for(int i = 1; i < dp.length; i++){
        dp[i] = Math.max(dp[i - 1], prices[i] - min);
        min = Math.min(min, prices[i]);
    }
    return dp[prices.length - 1];
}

//指定交易次数
public int maxProfit(int day, int[] prices) {
    if (prices.length <= 1) 
        return 0;
    int maxK = day, n = prices.length;
    if(maxK > n / 2) 
        return profit(prices);
    int[][][] dp = new int[n][maxK + 1][2];
    for (int i = 0; i < n; i++) {
        for (int k = 1; k <= maxK; k++) {
            if (i == 0) {
                dp[i][k][0] = 0;
                dp[i][k][1] = -prices[0];
                continue;
            }
            dp[i][k][0] = Math.max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]);
            dp[i][k][1] = Math.max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i]);
        }
    }
    return dp[n - 1][maxK][0];
}
//不限次数
int profit(int[] prices){
    int n = prices.length;
    int[][] dp = new int[n][2];
    for(int i = 0;i < n; i++){
        if(i == 0){
            dp[0][0] = 0;
            dp[0][1] = -prices[0];
            continue;
        }
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
    }
    return dp[n - 1][0];
}
```

## 遍历文件夹

```java
import java.io.File;
import java.io.FileFilter;
 
public class FileText {
	public static void main(String[] args) {
		String path = "D:\\JAVA";		//要遍历的路径
		File file = new File(path);		//获取其file对象
		func(file);
	}
	
	private static void func(File file){
		File[] fs = file.listFiles();
		for(File f:fs){
			if(f.isDirectory())	//若是目录，则递归打印该目录下的文件
				func(f);
			if(f.isFile())		//若是文件，直接打印
				System.out.println(f);
		}
	}
}
```

## 其他排序

- 选择排序，每次从后面找出最小的放入当前位置

```java
static class SelectSort {
    public static int[] selectSort(int[] a) {
      int n = a.length;
      for (int i = 0; i < n - 1; i++) {
        int min = i;
        for (int j = i + 1; j < n; j++) {
          if (a[min] > a[j]) min = j;
        }
        //交换
        int temp = a[i];
        a[i] = a[min];
        a[min] = temp;
      }
      return a;
    }
  }
```

- 插入排序，在当前位置前，选择合适的位置插入。

```java
public class InsertSort {
    public static int[] insertSort(int[] arr) {
      if (arr == null || arr.length < 2)
        return arr;
      int n = arr.length;
      for (int i = 1; i < n; i++) {
        int temp = arr[i];
        int k = i - 1;
        while (k >= 0 && arr[k] > temp)
          k--;
        //腾出位置插进去,要插的位置是 k + 1;
        for (int j = i; j > k + 1; j--)
          arr[j] = arr[j - 1];
        //插进去
        arr[k + 1] = temp;
      }
      return arr;
    }
  }
```

- 冒泡排序

```java
public class BubbleSort {
  public static int[] bubbleSort(int[] arr) {
    if (arr == null || arr.length < 2) {
      return arr;
    }
    int n = arr.length;
    for (int i = 0; i < n; i++) {
      boolean flag = false;
      for (int j = 0; j < n - i - 1; j++) {
        if (arr[j + 1] < arr[j]) {
          falg = true;
          int t = arr[j];
          arr[j] = arr[j + 1];
          arr[j + 1] = t;
        }
      }
      if(!flag)break;
    }
    return arr;
  }
}
```

- 希尔排序，插入排序的变种

```java
static int[] shellSort(int[] arr) {
  if (arr == null || arr.length < 2) return arr;
  int n = arr.length;
  // 对每组间隔为 h的分组进⾏排序，刚开始 h = n / 2;
  for (int h = n / 2; h > 0; h /= 2) {
    //对各个局部分组进⾏插⼊排序
    for (int i = h; i < n; i++) {
      // 将arr[i] 插⼊到所在分组的正确位置上
      insertI(arr, h, i);
    }
  }
  return arr;
}

/**
 * 将arr[i]插⼊到所在分组的正确位置上
 * arr[i]] 所在的分组为 ... arr[i-2*h],arr[i-h], arr[i+h] ...
 */
private static void insertI(int[] arr, int h, int i) {
  int temp = arr[i];
  int k;
  for (k = i - h; k > 0 && temp < arr[k]; k -= h) {
    arr[k + h] = arr[k];
  }
  arr[k + h] = temp;
}
```

- 计数排序，适合于最⼤值和最⼩值的差值不是不是很⼤的排序

```java
public static int[] sort(int[] arr) {
  if (arr == null || arr.length < 2) return arr;
  int n = arr.length;
  int min = arr[0];
  int max = arr[0];
  // 寻找数组的最⼤值与最⼩值
  for (int i = 1; i < n; i++) {
    if (max < arr[i]) max = arr[i];
    if (min > arr[i]) min = arr[i];
  }
  int d = max - min + 1;
  //创建⼤⼩为max的临时数组
  int[] temp = new int[d];
  //统计元素i出现的次数
  for (int i = 0; i < n; i++)
    temp[arr[i] - min]++;
  int k = 0;
  //把临时数组统计好的数据汇总到原数组
  for (int i = 0; i < d; i++) {
    for (int j = temp[i]; j > 0; j--)
      arr[k++] = i + min;
  }
  return arr;
}
```

- 桶排序

```java
public static int[] BucketSort(int[] arr) {
  if (arr == null || arr.length < 2) return arr;
  int n = arr.length;
  int max = arr[0];
  int min = arr[0];
  // 寻找数组的最⼤值与最⼩值
  for (int i = 1; i < n; i++) {
    if (min > arr[i])
      min = arr[i];
    if (max < arr[i])
      max = arr[i];
  }
  //和优化版本的计数排序⼀样，弄⼀个⼤⼩为 min 的偏移值
  int d = max - min;
  //创建 d / 5 + 1 个桶，第 i 桶存放 5*i ~ 5*i+5-1范围的数
  int bucketNum = d / 5 + 1;
  ArrayList<LinkedList<Integer>> bucketList = new ArrayList<>
          (bucketNum);
  //初始化桶
  for (int i = 0; i < bucketNum; i++) {
    bucketList.add(new LinkedList<Integer>());
  }
  //遍历原数组，将每个元素放⼊桶中
  for (int i = 0; i < n; i++) {
    bucketList.get((arr[i] - min) / d).add(arr[i] - min);
  }
  //对桶内的元素进⾏排序，我这⾥采⽤系统⾃带的排序⼯具
  for (int i = 0; i < bucketNum; i++) {
    Collections.sort(bucketList.get(i));
  }
  //把每个桶排序好的数据进⾏合并汇总放回原数组
  int k = 0;
  for (int i = 0; i < bucketNum; i++) {
    for (Integer t : bucketList.get(i)) {
      arr[k++] = t + min;
    }
  }
  return arr;
}
```

## 最大公约数

```java
static int gcd(int x, int y){
  int t;
  if(x < y){
    t = x;
    x = y;
    y = t;
  }
  while(y != 0){
    t = x % y;
    x = y;
    y = t;
  }
  return x;
}
```

## 素数判断

```java
boolean isPrime(int num) {
  //两个较小数另外处理
  if (num == 2 || num == 3)
    return true;
  //不在6的倍数两侧的一定不是质数
  if (num % 6 != 1 && num % 6 != 5)
    return false;
  int tmp = (int) Math.sqrt(num);
  //在6的倍数两侧的也可能不是质数
  for (int i = 5; i <= tmp; i += 6)
    if (num % i == 0 || num % (i + 2) == 0)
      return false;
  //排除所有，剩余的是质数
  return true;
}
```

## 设计模式

单例模式的优点：

1. 单例模式中，对单例类的所有实例化得到的都是相同的一个实例。

- 单例模式，懒汉式，双重校验

```java
public class SafeLazySingleton {

    private SafeLazySingleton(){
        System.out.println("生成SafeLazySingleton实例一次！");
    }

    private static SafeLazySingleton instance = null;
   //1.对整个访问实例的方法进行同步
    public synchronized static SafeLazySingleton getInstance(){
        if (instance == null) {
            instance = new SafeLazySingleton();
        }
        return instance;
    }    
    //2.对必要的代码块进行同步
    public static SafeLazySingleton getInstance1(){
        if (instance == null) {
            synchronized (SafeLazySingleton.class){
                if (instance == null) {
                    instance = new SafeLazySingleton();
                }
            }
        }
        return instance;
    }
}
```

> - 有了外层null判断为什么需要第二个？
>
> 在多线程环境下，可能两个线程A,B同时读取到instance为null，外层判断成立。若A先获得锁，先进入创建对象。然后出来B获得锁，他进入如果不判断`instance==null`，就会再创建一遍对象。
>
> - 去掉外层null判断，单例模式仍然有效，为什么还需要外层判断？
>
> 线程进入同步块的代价肯定是比不进入同步块的代价大的，假设B线程在A后执行，还未进入if判断，当A执行完时B就会跳过同步块。如果没有外层if判断，B线程需要进入同步块，获得锁，判断为null情况，再释放锁。徒增开销。

- 内部类方式更优雅。

```java
public class SingleTon {
    private static class SingleTonHolder{
        private static final SingleTon3 singleton = new SingleTon3();
        private SingleTonHolder(){}
    }
    private SingleTon3(){}
    
    public static SingleTon3 getInstance(){
        return SingleTonHolder.singleton;
    }

}

```

> 工厂模式

```java
public abstract class Pizza{
    protected String name;  //披萨的名字
    //准备原材料，因为不同的披萨不一样，所以做成抽象方法
    public abstract void prepare();
    public void bake(){
        System.out.println(name+"baking");
    }
    public void cut(){
		System.out.println(name+"cutting");
    }
    public void box(){
        System.out.println(name+"boxing");
    }
    public void setName(String name){
        this.name = name;
    }
}

public class CheezePizza extend Pizza{
    @Override
    public void prepare(){
        System.out.println(name+"boxing");
        //给奶酪披萨准备原材料
    }
}
public class GreekPizza extend Pizza{
    @Override
    public void prepare(){
        System.out.println(name+"boxing");
        //给希腊披萨准备原材料
    }
}
```





# SQL

## 第二高的薪水

```sql
select 
ifnull(
    (select distinct Salary 
    from Employee 
    order by Salary desc 
    limit 1,1),null)
as SecondHighestSalary
```

## 第N高的薪水

```sql
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
  set N = N - 1;
  RETURN (
    select distinct salary from employee order by salary desc limit N, 1
  );
END
```

## 分数排名

```sql
select s1.Score, count(distinct(s2.Score)) 'Rank'
from Scores s1, Scores s2
where s1.Score <= s2.Score
group by s1.Id 
order by s1.Score desc;
```

## 连续出现的数字

```sql
select distinct l1.Num ConsecutiveNums 
from Logs l1, Logs l2, Logs l3
where l1.Num = l2.Num 
  and l2.Num = l3.Num
  and l1.Id = l2.id - 1
  and l2.Id = l3.id - 1;
```

## 从不订购的客户

```sql
select c.`Name` Customers 
from Customers c
where c.Id not in(select CustomerId from Orders)
```

## 部门工资最高的员工

```sql
select d.`Name` Department, e.`Name` Employee, e.Salary 
from  Employee e join Department d on e.DepartmentId = d.Id
where (e.Salary, e.DepartmentId) in 
(select max(Salary), DepartmentId from Employee group by DepartmentId)
```

## 删除重复电子邮箱

```sql
delete from Person 
where Id not in(
  select minId
  from(
    select min(Id) as minId
    from Person
    group by Email
  ) as tempTable
)
```

## 上升的温度

```sql
select w1.Id 
from Weather w1, Weather w2 
where datediff(w1.RecordDate,w2.RecordDate) = 1 and w1.Temperature > w2.Temperature;
```



# 测试开发

## 压力测试指标

1.TPS
每秒钟完成的web请求响应数量（TPS=并发数/响应时间）

2.并发数
时间段内，系统同时处理的web请求响应数量

3.响应时间
所有web请求处理完毕的时间

4.吞吐量
吞吐量指的是单位时间系统传输数据总量。
吞吐量和TPS,并发数这两个因素是正比关系。
但是当TPS,并发数达到极限值时，吞吐量不升反降，这是因为系统资源产生了大的消耗。

5.PV
页面浏览量。服务器页面每刷新一次，算作一次PV流量。
IP/PV比：指的是单个IP页面浏览量，该指标可以说明此次访问有效率。

## 测试的目的

测试的目的是为了发现尽可能多的缺陷。

测试只能证明缺陷存在，而不能证明缺陷不存在。

## 微信红包测试用例

金额：边界数值

留言：特殊字符，中英文支持

表情：收藏的表情，拍照表情支持

塞钱进红包：零钱，银行卡选择，余额是否大于金额。

输入密码/指纹：密码正确/错误。

好友点击红包，余额增加，24h未点击，红包返回余额。

兼容性测试：安卓，IOS，iPadOS

性能测试：打开红包的延迟。

易用性测试：界面风格简洁，易操作，易理解。

网络测试：兼容性：2/3/4g，wifi，热点，电信移动联通。

## 测试主要内容与常用方法

**（1）正确性测试（功能测试）**

　　正确性测试又称功能测试，它检查软件的功能是否符合规格说明。由于正确性是软件最重要的质量因素，所以其测试也最重要。

**（2）容错性测试**

　　容错性测试是检查软件在异常条件下的行为。容错性好的软件能确保系统不发生无法意料的事故。

**（3）性能与效率测试**

　　性能与效率测试主要是测试软件的运行速度和对资源的利用率。有时人们关心测试的“绝对值”，如数据送输速率是每秒多少比特。有时人们关心测试的“相对值”，如某个软件比另一个软件快多少倍。

**（4）易用性测试**

　　易用性测试没有一个量化的指标，主观性较强。调查表明，当用户不理解软件中的某个特性时，大多数人首先会向同事、朋友请教。要是再不起作用，就向产品支持部门打电话。只有30%的用户会查阅用户手册。

**静态测试**

静态测试的含义是被测程序不运行，只依靠分析或检查源程序的语句、结构、过程等来检查程序是否有错误。即通过对软件的需求规格说明书、设计说明书以及源程序做结构分析和流程图分析，从而来找出错误。例如不匹配的参数，未定义的变量等。

**动态测试**

动态测试与静态测试相对应，其是通过运行被测试程序，对得到的运行结果与预期的结果进行比较分析，同时分析运行效率和健壮性能等。这种方法可简单分为三个步骤:构造测试实例、执行程序以及分析结果。

**白盒测试**

从程序结构出发设计测试用例，查看各个逻辑模块是否有效。

采用白盒法可以用测试覆盖率作为测试彻底度的定量衡量标准。常用的覆盖率有: 

(1)语句覆盖:要求设计足够的测试数据，使程序的每条语句都至少执行一次。 

(2)判定覆盖(分支覆盖):使程序中的每个判定至少出现一次“真值”和一次假值”，即程序中的每个判定(分支)都至少要经过一次。 

(3)条件覆盖:使判定中每个条件的所有可能的结果至少出现一次，并且使每条语句至少执行一次。

(4)判定条件覆盖:使判定覆盖和条件覆盖同时得到满足。 

(5)多重条件覆盖:又称条件的组合覆盖，是使程序中每个判定中的条件的各种组合都至少取到一次，并且每条语句至少执行一次。 

此外，还有诸如路径覆盖(程序中每条路径至少执行一次)、基本路径覆盖(循环次数只考虑小于等于一次所组成的程序路径，每条基本路径至少执行一次)等。为了获取测试覆盖率(不论是哪一种覆盖率)需要有测试工具的帮助，且需要花费人力与机时去做测试工作(设计测试用例、输入测试数据、进行统计计算等。

**黑盒测试**

不考虑程序内部结构，根据需求说明设计测试用例，只看结果是否符合要求。

> 考虑如下问题：
>
> 1. 怎样测试功能的有效性
> 2. 哪些类型的输入可构成好的测试用例
> 3. 怎么划定数值边界
> 4. 系统能承受的数据量

- 等价类划分

1. 等价类的分类

   有效等价类：指符合《需求规格说明书》，输入合理的数据集合。

   无效等价类：指不符合《需求规格说明书》，输入不合理的数据集合。

2. 等价类思考步骤

   （1）先确定有效和无效等价类

   （2）有效等价类就是题目条件（两端的极值（边界值）要判断、中间随意一个值也要判断）

   （3）无效等价类先划分与条件相反的情况，再找到特殊情况（中文、英文、符号、空格、空）

- 边界值分析

按照健壮性边界值分析的取值方法，对每个输入分别取7个值，即为min-、min、min+、normal、max-、max和max+。

- 错误推测法

靠经验和直觉推测程序中可能产生的错误

- 因果图法

分析出哪些是原因，那些是结果。给予每个原因和结果一个标识符。

分析规格说明中描述的语义，找出原因和结果之间的关系。



**灰盒测试**

灰盒测试则介于黑盒测试和白盒测试之间。灰盒测试除了重视输出相对于出入的正确性，也看重其内部表现。但是它不可能像白盒测试那样详细和完整。它只是简单的靠一些象征性的现象或标志来判断其内部的运行情况，

**自动化测试**

预先设计好测试程序，运用工具进行测试。





## 测试流程

- 单元测试
  从程序的内部结构出发设计测试用例，通常为白盒测试。针对程序模块（函数，类过程）进行正确性检验的工作。
- 集成测试
- 系统测试
- 验收测试

## 定位bug

这个bug的来源是属于前端还是后端。抓包看数据，请求的URL正不正确，传参数，接口返回数据格式等等问题。

## 测试用例要素

1. 用例编号
2. 测试模块
3. 用例标题
4. 测试级别
5. 测试目的和条件
6. 测试输入
7. 操作步骤
8. 预期结果

## 软件生命周期

1. 问题定义规划
2. 需求分析，评审
3. 软件设计
4. 软件编码
5. 软件测试
6. 软件运营维护

# 布隆过滤器

一个位图数组（可以用int或long类型表示），设长度为m。

通过对输入进行hash计算，对m取模，把数组对应位置为1，一个输入经过k个不同的hash函数计算，并设置对应位。

对所有的数据进行这样处理。

当一个新的输入进来时，进行k个hash函数计算，如果所有计算结果的位置都为1，那么改数据肯定是要过滤的数据。有一次不为1，就不是过滤的数据。但也存在失误。

假设数据量为`n = 100亿`，失误率为`p = 0.0001`。

>  $m = -\frac{n \ln P} {\ln 2^2}$
>
> $k = \frac{m \ln 2}{n}$

# 一致性哈希

