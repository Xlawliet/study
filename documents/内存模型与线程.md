# 内存模型与线程

每秒任务的处理数（transactions per second，TPS）



指令重排序优化；



JVM规范中试图定义一种java内存模型来屏蔽掉各硬件和操作系统之间的内存访问的差异，使得在各个平台下java程序都能达到一致内存访问效果；

java内存模型的主要目标时定义程序中各个变量的访问规则；



#### 内存间交互操作

以下8种操作都是原子的、不可再分的：

- lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态；
- unlock（解锁）：将处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定；
- read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用；
- load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中；
- use（使用）：作用于工作内存的变量，将变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时，就会执行这个操作；
- assign（赋值）：把一个从执行引擎接受到的值赋给工作内存的变量，每当虚拟机遇到一个变量赋值的字节码时执行这个操作；
- store（存储）：把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用；
- write（写入）：把从store操作从工作内存中得到的变量的值放入到主内存的变量中；



**Volatile**

禁止指令重排；

保证变量可见；

原子性操作；



**线程**：

主要线程调度方式有两种：

协同式线程调度，抢占式线程调度；

协同式调度：执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另一个线程上，优点在于实现简单，做完事情干完之后才会进行线程切换；

抢占式调度：每个线程将有系统来分配执行时间，线程的切换不由线程本身来决定，在这种方式下，线程的执行时间是系统可控的，也不会因为一个线程导致整个进程阻塞的问题，java使用的就是抢占式调度；



java语言中一共设置了10个级别的线程优先级，在两个线程同时处于ready状态时，优先级高的线程越容易被系统选择执行；

**线程状态：**

新建（New） 创建尚未启动

运行（Runable） Runable包括了两种状态的，Running和Ready，可能正在执行，也可能正在等着CPU分配执行时间；

无限期等待（Waiting） 处于此状态的线程不会被分配CPU执行时间，它们要等待被其他线程显示地唤醒；

限期等待（Timed Waiting） 处于这种状态的线程也不会被分配CPU执行时间，不过无需等待被其他线程显示的唤醒，一定时间后会由系统自动唤醒；

阻塞（Blocked） 该状态与等待状态的区别时，该状态在等待着获取一个排它锁，等另一个线程放弃这个锁的时候发生；

结束（Terminated） 已终止线程的线程状态，线程已经结束执行；



**java中共享的数据分为以下5类：**

不可变： 不可变对象一定时线程安全的，如final关键字修饰的变量，只要一个不可变对象被正确的构建（没出现引用逃逸的情况），那外部的可见状态永远也不会改变；调用substring、replace等方法都不会影响它原来的值，只会返回一个新构造的对象；



绝对线程安全：不管运行时环境如何，调用者都不需要任何额外的同步措施；



相对线程安全：是我们通常意义上的线程安全，如Vector，Hashtable等集合；



线程兼容：指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，如Arraylist，Hashmap；



线程对立：指无论是否采取了同步措施，都无法在多线程环境中并发使用的代码；



**线程安全的实现方法**：

互斥同步：是一种常见的并发正确性保障手段，多个线程并发访问共享数据时，同一时刻只被一个线程锁使用。使用临界区、互斥量（mutex）、信号量（semaphore）都是主要的互斥实现方式。互斥是方法，同步是目的；除了使用synchronized之外，还可以使用JUC中的重入锁（ReentrantLock）来实现同步；

Reentrantlock：相比synchonized增加了一些高级功能：等待可中断、可实现公平锁、以及锁可以绑定多个条件；



非阻塞同步：互斥同步最主要的问题就是进行线程阻塞和唤醒锁带来的性能问题，因此这种同步也成为阻塞同步；如CAS；



无同步方案：方法本身不涉及共享数据，天生就是线程安全的，如可重入代码，也叫做纯代码、和线程本地存储；



**锁优化：**

（忙循环）自旋锁和自适应自旋：

自旋锁默认为10次，可通过参数来改变；

1.6引入自适应自旋，由前一个在同一个锁上的自旋时间及锁的拥有者的状态来决定；



**锁粗化**：

将锁直接加到运行的代码块，如

```java
StringBuffer sb = new StringBuffer（）；
int i = 0;
while（i<100）{
sb.append(str);
}
```

锁会直接加在while语句块上；