1.进程间通信

由于不同的进程拥有独立的用户地址空间，所以某一个进程内的变量在另一个进程内是不可见的，如果它们需要通信，则需要借助操作系统。

匿名管道：匿名管道实际上是存在于内存中的一种特殊的文件系统。它类似于一个先进先出的队列。匿名管道是半双工的，即数据只能单向流动。数据只能在管道一端写入，另一段读取。只有管道的读端存在时，写端才有意义，否则写数据的进程将会收到内核传来的信号，进程可以处理该信号也可以忽略（默认动作是进程终止）。匿名管道通信的双方必须是具有亲缘关系的两个进程(父子进程或兄弟进程)。同时，由于管道传递的是字节流，通信的双方必须约定好信息的格式。

命名管道：命名管道的数据可以单向或双向流动。它可以支持一台主机上任意两个进程间通信。这是因为命名管道是一个存在于磁盘或者文件系统上的文件，它提供了一个路径名，可以让所有进程都能找到。命名管道严格遵循先进先出的规则，总是从文件头读取数据，而把数据写到文件尾，不支持文件定位的操作。

消息队列：消息队列是存在于系统内核中的消息链表，只有当内核重启或者显式关闭时消息队列才会被关闭。这样做的好处是让消息队列独立于通信的进程而存在。与管道相比，消除了同步打开的困难。消息队列传递的数据都是一个个的消息块，消息块可以有格式，消除了管道字节流通信的困难。消息队列可以同时给多个进程通信。同时因为消息队列是独立于通信进程的，所以写端写数据时，允许另一端没有接收消息的读端。

信号：信号是软件层次上对于中断机制的一种模拟。信号的来源有两个。 
硬件来源：用户输入ctrl+c退出，硬件异常，如无效的存储访问。
软件来源：软件异常，其它进程调用kill函数。
信号被某个进程产生，设置该信号接收进程，然后传递给操作系统。如果接收进程阻塞了该信号，操作系统将暂时保存，知道解除阻塞后发送该信号。接收进程收到信号，暂时终止执行，保护上下文，执行中断服务程序，执行完成后回到中断的位置。

共享内存，是效率最高的进程通信方式，因为它在传递数据时无需对数据重复拷贝，且不依赖于系统调用。但是使用共享内存时需要注意互斥访问。

---

2.进程调度的算法

先来先服务(FCFS)，操作系统每次从就绪队列选择一个最先进入队列的进程，为它分配处理机，直到进程运行结束或发生某事件中断而放弃处理机。 这种算法的缺点是如果有一个长进程长时间占有处理机，则队列里其它进程就会一直得不到调度。这种算法对于短进程不友好。

短作业优先(SJF)，操作系统每次会从就绪队列中选择一个估计运行时间最短的进程调入内存运行。这种算法缺点是对于长进程不友好。

时间片轮转法，操作系统先把所有进程按照先来先服务的策略排成一个队列，然后对于每一个进程运行固定大小的时间，若进程没有运行完，则把该进程送到就绪队列尾部。 这种算法的缺点是时间片选择问题，太大时同FCFS算法，太小时，队列会轮转太多次，反而影响了时间效率。

多级反馈队列调度算法，设置多个队列，第一级队列优先级最高，但是运行时间最短，刚开始所有进程都在一级队列里。操作系统依次取出进程运行，若在一级队列规定的时间片里进程结束就把进程丢出队列，否则中断后送入下一级队列。只有当高等级队列为空时，才开始处理低等级队列中的进程。若在此过程中又有新的进程加入高等级队列，则会抢占处理机。 这种算法是目前公认的比较好的调度算法。

优先权调度算法，操作系统优先调度权重最高的进程。这种算法又分为抢占和非抢占式。 一种优化：让权重随时间增加而增加。

---

3.进程和线程的区别

一个程序至少有一个进程，一个进程至少有一个线程。
进程是操作系统进程资源分配的最小单位，线程是操作系统调度的最小单位。
一个进程中的所有线程共享进程拥有的全部资源，但线程也具有自己的独立的一些资源(如程序计数器等)。
线程的粒度比进程小，线程调度开销要小一点。

---

4.死锁产生的四个必要条件
互斥条件：一个资源每次只能被一个进程使用
不可强占有： 进程在获得资源后，未使用完之前，不能强行剥夺
占有且等待：一个进程因为请求资源而阻塞时，对已经获得的资源保持不放
循环等待

---

5.银行家算法

银行家是用来避免死锁的， 即在操作系统进行资源分配的时候就考虑时候会产生死锁。
它是这样一个流程。
假设有n个进程,m类资源。

假如现在有一个资源请求。
算法第一步检查这个进程请求的资源加上它已经占有的资源是否超过了它需要的最大资源，如果是，直接拒绝这次请求。否则进入第二步。
第二步判断请求的资源数量是否超过了现在操作系统有的资源数量。如果是，就拒绝。
第三步，操作系统试探着分配资源，并执行一个安全算法，如果安全算法返回假，就拒绝，否则就真的分配了。

安全算法是这样的，操作系统从所有没有执行完毕进程里选择一个满足条件的：该进程目前占有的资源加上操作系统现在所拥有的全部资源超过它执行完毕需要的最大资源。如果找到了，我们就回收这个进程占有的资源，并标记它已经执行完毕。 接着就是循环这个过程，如果所有进程都能执行完毕，那么这个系统就是安全的，否则不安全。 并且称寻找过程的进程序号是安全序列。因为只要按照这个顺序分配资源，一定不会死锁，所有进程都能执行完。

---

6.虚拟内存和内存分页

在应用程序看来，它所占有的内存是一段连续的空间。但实际并非如此，在实际的物理内存中，一个进程占有的内存可能是一些一些的块拼接起来的。在进程内部，它占有的内存我们就称为虚拟内存。 把虚拟内存向物理内存映射，是通过MMU(内存管理单元）来实现的。

这样做的好处：操作系统实际上对上层应用程序屏蔽了物理地址的细节， 这样两个进程就不会出现彼此修改对方的数据了，因为它根本无法访问到真实的物理地址。
另外，一个程序可以使用超过真实内存大小的空间，利用虚拟内存对于磁盘的映射，我们可以把不常用的数据都先存在磁盘上。

内存分页：其实就是建立虚拟内存与物理内存一对一的映射，但是我们不可能一个字节一个字节的映射，这样的话光存储内存就炸了。 所以我们把一个页作为最小的映射单位，通常一页是4096个字节(4KB)，linux系统可以采取“getconf PAGE_SIZE”这个命令获得页大小。 这样要记录的东西只有字节总数的1/4096了。这个对应关系称为页表，是存储在内存中的。 另外，页表还能继续映射，那这个就是多级页表了。

---

7.页面置换算法

操作系统发现要访问的页面不在内存，就会产生缺页中断，并且内存没有空闲页面了，操作系统就需要决定把哪个页面调出内存。这个决定调出哪个页面的算法就叫做缺页中断算法。
一个比较好的算法叫做LRU（最近最久未使用算法），LRU会选择最近一段时间内最久没有使用的页面，把它移出内存。

---

8.linux IO模型
为了方便理解，我以正在通信的两台主机上的进程为栗子

阻塞IO模型，上层应用程序向TCP缓冲区请求数据时，若数据未到达会阻塞进程，直到数据到达或者返回一个错误。

非阻塞IO模型，上层应用程序向TCP缓冲区请求数据时，若数据未到达会直接返回，在此过程中进程可以去做其他事。

多路IO复用模型，主要运用在高并发的场景里，若应用程序需要接收来自多个发送方的数据，最简单的做法自然是创建多个线程，但这样的开销巨大。多路IO复用使用一个线程监听多个文件描述符，出现就绪的sock时通知上层进程读取数据。
多路IO复用有3类实现，select和poll做法类似，都是先把fd数组从用户空间复制到内核，然后不断轮询检查已经就绪的文件描述符。实际上，poll(底层是链表)可以看成是对select(底层是数组)的一个优化，select限制了监听的连接数量(32bit机器是1024，64bit机器是2048)，select会修改传入的数组，这对多次函数调用不友好，poll优化了这些缺点。epoll是对select和poll的进一步优化，epoll使用事件驱动，当内核的IO流发生状态变化，会通知应用程序。epoll的底层是hash。

信号驱动IO模型，其实和epoll差别就在于少了一层监听fd的线程。内核直接通知应用程序哪些fd就绪。

异步IO模型，应用程序直接告诉内核当fd状态就绪后，把数据拷贝到用户内存空间。

水平触发和边沿触发。
水平触发，只要fd里有数据可读，就会一直发出可读信号通知。
边沿触发，只有等待下次IO信号到来时才会发出信号通知。










