单例模式

目的是为了解决项目中频繁删除和创建一个实例，为了节省系统资源而控制实力数目的设计模式。

使用场景：要求产生唯一序列号；创建一个对象需要消耗的资源过多，比如I/O与数据库的连接等。

懒汉、饿汉、双重检查、静态内部类

#### 类的加载

加载：

将class文件转化为二进制数据

连接：

验证：

1. 文件格式验证：验证字节流是否符合Class文件格式的规范
2. 元数据验证：对字节流描述的信息进行语义分析
3. 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
4. 符号引用验证：确保解析动作能正确执行。

准备

为静态变量分配内存，并将其初始化为默认值

解析

把类中的符号引用转化为直接引用

初始化

初始化，为类的静态变量赋予正确值，JVM负责对类进行初始化，主要对类变量进行初始化。

#### mysql 非聚簇索引 叶子节点存储的东西是什么

叶子结点存储的是包含索引字段值以及指向数据页数据行的逻辑指针，其行数量与数据表行数据量一致。

#### 联合索引的查询规则是什么

最左前缀匹配原则，其原理就是一个元组排序，或者说是通过多个字段生成的搜索树，会依次匹配所传入条件，直到找到所需要的一条数据或一个范围内的数据。

当我们的查询条件与联合索引创建时的字段顺序不同时，mysql会自动排序，优先找到生成索引时的字段顺序，然后再依次进行匹配。



#### 索引建立的原则

#### 索引的大小



#### 提交读，可重复读

https://www.cnblogs.com/aspirant/p/10572560.html



#### mysql结构 

redo log  undo log



#### cookie和session

由于http是无状态协议，所以服务端需要记录用户状态的时候，就需要某种机制来识别具体的用户，从而诞生了cookie和session。

cookie和session分别保存在客户端和服务端中。

当用户访问一个网站后，会生成对应的cookie和session。当用户再次访问网页时，会发送本地存储的cookie，其中带有用户的登录信息以及用户的信息等。服务器接收之后会从中取得对应的sessionId，再通过这个id在服务器中查询对应的session是否存在，如果不存在则认为没有该用户的信息，需要重新生成，如果有对应的session，用户则无需再次登录，并且能够快速的获得该网页中的信息，如购物车中存放的商品信息等。

#### token

token也是一种服务器端无状态的认证方式。其中保存的信息有uid，time，sign等，在客户端中一般存放在cookie中，服务器端一般存放在数据库中。使用token可以抵抗csrf攻击。token在分布式的情况下可以较好的解决负责均衡问题，这个方法叫做JWT(Json Web Token)

#### 反射

反射是指程序在运行中，对于任何一个类，都可以得到这个类的所有方法和属性；对于任何一个对象，都可以调用它的任意一个方法和属性；

优点：可以实现动态创建对象和编译，体现出很强大的灵活性；

缺点：总是慢于我们直接在程序中去获取指定的方法和属性；破坏了类的封装。

#### Spring AOP

AOP可以将与业务无关，却为业务模块共同调用的逻辑或责任(事务处理、日志管理、权限控制等)封装起来，便于减少系统的重复代码，降低耦合度，有利于未来的拓展性和可维护性。

主要概念：切入点、通知、切面、织入。

实现方法：通过==预编译方式==和==运行期动态代理==实现的。

其中动态代理就是用到了jdk中java的反射机制来获得所需要代理的类，并对该类创建代理类。

获得代理类后，java就可以在通过注解等方式来找到指定的切点，并在此进行对应的操作，形成切面。

通知的分类：

前置：在目标方法被调用前调用通知方法；

后置：在目标方法被调用后调用通知方法；

异常：在目标方法抛出异常后调用通知方法；

返回：在目标方法成功执行之后调用通知方法；

环绕：把整个目标方法包裹起来，在调用前以及调用之后分别调用通知方法；

静态织入（AspectJ）：是Java自带的AOP框架，能够对代码进行编译；

动态代理（Spring AOP）：通过动态代理技术实现的。

#### HashMap和TreeMap

TreeMap是基于红黑树来进行存储的，保证了存入数据是按顺序进行存储的，同时还可以在存入数据时对数据进行升序（降序）排序。

HashMap是基于桶进行排序的，存入顺序是无序的，且不保证当前数据的顺序是不变的。

#### 索引慢如何解决

首先判断所构建的索引和实际使用的情况是否够用；

当使用了索引却仍然效率低的话，需要分析索引对应的列，判断该列是否适合被用作索引的条件，该列是否可以为空，以及该列的使用次数是否够多，如果该列的使用次数不多就不应该用作索引；查询的条件中是否使用了 != or in like等判断方法，使用这些判断会使得查询无法走索引；索引的建立是否合适，应该将能过滤掉大部分数据的条件放在前，可以使得后面的条件能够更快的被匹配，更快的缩小查询范围；定期分析表和检查表，定期优化表(清理数据)

0.先运行看看是否真的很慢，注意设置SQL_NO_CACHE

1.where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高

2.explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）

3.order by limit 形式的sql语句让排序的表优先查

4.了解业务方使用场景

5.加索引时参照建索引的几大原则

6.观察结果，不符合预期继续从0分析

#### sql调优

show status like 'Innodb_%' 来查询对应的语句被执行的次数，了解到数据库的应用是以那种操作为主。

通过show processlist命令来查看当前mysql在进行的线程，可以实时的查看sql的执行情况，同时对一些锁表操作进行优化。

通过上述方法获得效率低的sql后，使用explain命令或desc命令获取查询语句的信息。

mysql4.1之后还引入了explain extended 来查看sql真正被执行之前优化器做了哪些sql改写。

使用trace分析优化器如何选择执行计划。

#### 线程同步

1、同步方法

通过使用synchronized关键字修饰方法；由于java中每个对象都有一个内置锁，用该关键字修饰方法时，内置锁会保护整个方法。

==注：用synchronized修饰静态方法，会锁住整个类==

2、同步代码块

通过使用synchronized修饰语句块。被该关键字修饰的语句会被自动加上内置锁，从而实现同步。

3、使用特殊变量（volatile）实现线程同步

volatile为域变量的访问提供了一种免锁机制。

使用该关键字修饰变量，相当于告诉虚拟机该变量可能会被其他线程更新。

所以每次使用该变量时，都会到内存中重新获取该变量的值。

4、使用重入锁实现线程同步

通过使用JUC包来支持同步。ReentrantLock时可重入、互斥、实现了Lock接口的锁。

它与synchronized方法具有相同的基本行为和语义，并且扩展了其能力。

关于Lock和synchronized的选择：如果真的需要线程同步，优先选用synchronized来满足，因为它能简化代码，当需要使用到更高级的功能时，再使用Lock或ReentrantLock类，此时要主要及时释放锁，否则会出现死锁，通常在finally块中释放锁。

5、使用局部变量ThreadLocal实现线程同步

如果使用ThreadLocal管理变量，则每一个使用该变量的线程都将获得该变量的副本，副本之间相互独立，这样每个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。解决了多线程中相同变量的访问冲突问题。

6、使用阻塞队列实现线程同步

如使用LinkedBlockingQueue来实现线程的同步，其实现时给予FIFO，put()在队尾添加元素，如果队列满则阻塞,size()返回队列中元素个数,take()移除并返回队头元素，如果队列为空则阻塞。

注意三种添加元素的方式，当队列满时： add()方法会抛出异常,put()方法会阻塞,offer()方法会返回异常

7、使用原子变量实现线程同步

如使用JUC的atomic包中的原子类可以简化线程同步。以原子方式来更新变量的值。

addAndGet() 以原子方式将给定值与当前值相加，get() 获取当前值

#### 各种锁

https://www.cnblogs.com/jyroy/p/11365935.html

乐观锁：认为获取资源时永远不会发生竞争，所以不会加锁，最常用的是CAS算法。

悲观锁：认为获取资源时会有其他线程同时竞争，所以在获取到资源时会对其加锁，而其他需要获取相同资源的线程则会等待锁释放。



自旋锁：CAS

适应性自旋锁：JDK 6 之后引入，使得自选的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么jvm认为这次自旋也是很有可能再次成功，进而允许自旋等待更长的时间。其他的相反。



无锁，偏向锁，轻量级锁，重量级锁

这四种锁指的是锁的状态，专门针对synchronized。

Java对象头：

Mark Word：默认存储对象的HashCode，分代年龄和锁标志位信息。

klass Point：对象指向它的类元数据指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

Monitor：

可以理解为一个同步工具，通常被描述为一个对象。Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。JDK6之前 synchronized一直是重量级锁，使得效率低。JDK6之后为了减少获取锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁。锁只能升级，不能降级。

无锁：锁标志位01没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。

偏向锁：是指一段同步代码或对象一直被一个线程锁访问，那么该线程会自动获取锁，降低获取锁的代价。当线程访问同步代码块并获取锁时，会在MarkWord里存储偏向锁的线程Id，在线程进入和退出时不再通过CAS来操作加锁和解锁，而是检测MarkWord里是否存储着指向当前线程的偏向锁。

轻量级锁：当锁是偏向锁时，被另外的线程锁访问，偏向锁就会升级为轻量级锁，锁标志变为00，MarkWord里会存储当前线程的Id，其他线程就会通过自旋的形式获取锁，不会阻塞，从而提高性能。若当前只有一个等待线程，则该线程通过自旋进行等待。当自旋超过一定次数时，或者一个线程在持有锁，一个在自旋，又有第三个线程来访时，轻量级锁就会升级为重量级锁。

重量级锁：锁标志变为10，此时MarkWord中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。



公平锁：公平锁是指，多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。优点是等待锁的线程不会饿死，缺点是吞吐率低，等待队列中除了第一个线程以外所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。

非公平锁：是多个线程加锁时直接尝试获取锁，获取不到才会进入队列的队尾等待。如果此时锁刚好可以获取，那么这个线程可以无需阻塞直接获取锁。优点是可以减少唤起线程的开销，整体的吞吐率高，因为线程有几率不阻塞直接获得锁，所以CPU不必唤醒所有线程。缺点是队列中的线程可能会饿死，或者很久之后才能获取锁。



可重入锁：锁可以被当前线程重复获得，一定程度上避免死锁，

独享锁：也叫排他锁，指该锁只能被一个线程锁持有，如果一个数据A已被一个线程加上排他锁，那么其他线程就不能再对A加其他锁。

共享锁：共享锁指该锁可以被多个线程锁所持有，如果线程T对数据A加上了共享锁，那么其他线程只能对A加共享锁，而不能加排他锁，获得共享锁的线程只能读该数据，不能进行写操作。

这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在

#### 分布式锁

数据库锁做分布式锁，基于乐观锁。这把锁强依赖于数据库的可用性，

如果数据库挂掉，那么会导致业务不可用。可以通过多个数据库，双向同步，一旦数据库挂掉立刻切换到备库。

锁没有失效时间，一旦解锁失败，会使得锁记录一直在数据库中，其他线程无法再获得。可以做一个定时任务，每隔一段时间就把数据库中的超时数据清理一遍。

这把锁只能是非阻塞的，否则insert操作一旦失败就会直接报错。可以添加一个while循环，直到insert成功。

通过数据库做分布式锁的优点是简单，易于理解。但缺点就是会有各种各样的问题，需要通过消耗性能来解决对应的问题。



redis做分布式锁

https://zhuanlan.zhihu.com/p/42056183

基于redis的setnx(),expire()方法，如果再expire命令之前发生宕机，会出现死锁。

基于上述问题可以通过 redis的 setnx()，get(),getset()方法来做分布式锁。

基于redLock做分布式锁。设置多个redis节点，通过向多个节点同时获取锁，如果能得到大多数节点的锁，则认为成功获取锁，若失败则会依次删除所有的锁。优点是性能高，缺点是失效时间的长短不好判断。

基于redisson做分布式锁，可以很好的解决上面的问题。每获得一个锁时，只设置一个很短的超时时间，同时起一个线程在每次快要到超时时间时去刷新锁的超时时间。在释放锁的同时结束这个线程。



基于zookeeper做分布式锁

- 原理：利用临时节点与 watch 机制。每个锁占用一个普通节点 /lock，当需要获取锁时在 /lock 目录下创建一个临时节点，创建成功则表示获取锁成功，失败则 watch/lock 节点，有删除操作后再去争锁。临时节点好处在于当进程挂掉后能自动上锁的节点自动删除即取消锁。
- 缺点：所有取锁失败的进程都监听父节点，很容易发生羊群效应，即当释放锁后所有等待进程一起来创建节点，并发量很大。



#### SpringBoot 启动流程



通过springboot项目中的main为入口，启动该项目。

通过springbootApplication.run（）启动，同时应用启动计时器，启动监视器开始监听。

initialize初始化模块，创建初始化构造器，监听器。

获取构造器（工厂）对象，得到所需工厂的实例，其中通过类反射得到工程的class，构造方法等，返回实例。加入IOC容器中。



#### String.intern()



#### 设计模式 head first

策略模式

门面模式

代理

享元