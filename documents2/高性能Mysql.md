# 高性能Mysql

## 逻辑架构

第一层：大多数基于网络的客户端/服务器的工具等架构，如连接处理，授权认证，安全等；

第二层：核心功能服务都在这一层，包括查询解析、分析、优化、缓存等。跨存储引擎的功能都在这一层：存储过程，触发器，视图；

第三层：包含存储引擎；



### 连接管理

每个客户端连接都会在服务器进程中拥有一个连接。服务器会负责缓存线程，所以不需要为每一个新建的连接创建或销毁线程；使用SSL方式进行连接。

### 优化与执行

Mysql会解析查询，并创建解析树，对其进行优化，包括重写查询，决定表的读取顺序，选择合适的索引等；用户可以通过优化器解释（explain）优化过程的各个因素，可以指导服务器时如何进行决策优化的；也可以使用hint来影响决策过程；

### 锁粒度

提高共享资源并发性的方式就是让锁定对象更有选择性。 尽量只锁定需要修改的部分数据，而不是所有资源。

#### 表锁

是基本的锁策略，开销最小，会锁定整张表。只有添加写锁的时候才会阻塞其他用户的读写操作，读锁之间是不互相阻塞的；写锁的优先级高于读锁，更容易争抢到锁；

#### 行级锁



### 基准测试

指标：数据库在一定工作负荷量的情况下的响应时间，

#### 测试工具

集成式测试工具

单组件式测试工具







## 索引和锁

索引能够过滤掉不需要访问的行，从而减少锁的数量（InnoDB的行锁），减少额外的开销；

从存储中进行读取时，尽可能在一次IO中取出包含尽可能多所需要的行。

按顺序访问范围数据，因为IO不需要多次磁盘寻道，所以比随机IO要快很多。并且不需要额外的排序操作。

索引覆盖查询很快，如果一个索引包含了查询需要的所有列，那么存储引擎就不需要再回表进行查询。

### 冗余索引和重复索引

如果创建了索引（A，B） 再创建索引（A）就是冗余索引，而索引（B,A）和索引（B）都不是冗余索引；

### 优化索引

1、支持多种过滤条件；2、避免多个范围条件、



## 慢查询优化

### 优化数据访问

#### 是否向数据库访问了不需要的数据

1. 查询了不需要的记录；
2. 多表关联的时候返回了全部列
3. 总是取出全部列 （select *）
4. 重复查询相同的数据

#### 是否在扫描额外的记录

1. 响应时间
2. 扫描的行数和返回的行数   有时候扫描了n行 却只返回了若干行
3. 扫描的行数和访问类型

#### 重构查询的方式

1. 使用一个复杂查询还是多个简单查询
2. 切分查询   将一个范围很大的查询分成多个功能相同 范围不同的小查询，有时这样更有效
3. 分解关联查询      执行单个查询可以减少锁的竞争，可以减少冗余记录的查询；



#### 优化的总结

理解查询是如何被执行的以及时间都消耗在了什么地方。

优化所作的时间一般是：不做，少做，快速的做；



## 高级特性

#### 分区表

实现分区的代码实际上是对一组底层表的句柄对象的封装。

在创建表时通过使用**partition by**来定义每个分区存放的数据，这样在执行查询的时候，优化器会根据分区定义过滤掉没有我们需要数据的分区，这样就无需扫描所有分区。

作用：

- 表非常大时无法全部存放在内存中，或者只在表的最后部分有热点数据，其他均是历史数据
- 分区表的数据更容易维护，比如可以批量删除大量的数据可以使用清除整个分区的方式，或对一个独立的分区进行优化，检查，修复等操作。
- 分区表的数据可以分布在不同的物理设备上，从而高效的利用多个硬件设备。
- 可以在一定程度上避免某些特殊的瓶颈，如在innodb中的单个索引的互斥访问。

限制：

- 一个表最多只能由1024个分区
- 分区表中无法使用外键约束

#### 视图

对多个表的复杂查询，使用视图时会大大简化问题。 

#### 外键约束

#### 查询缓存

Mysql查询缓存会保存查询返回的完整结果，当查询命中该缓存，mysql会立刻返回结果，跳过了解析、优化和执行阶段。

如果表被修改，那么缓存数据都将失效。

##### 判断是否命中缓存：

查询本身、当前要查询的数据库、客户端协议的版本等。

如果查询语句中包含不确定的数据，则不会被缓存，如DATE（），NOW（）等，并且如果查询中包含用户自定义函数、用户变量、存储函数等，都不会被缓存。



查询缓存时完全存储在内存之中的。

缓存未命中的原因：

- 查询语句无法被缓存，或者查询结果太大而无法缓存。
- 当前查询从未被处理过，所以结果也没有被缓存过。
- 虽然之前缓存了查询结果，但由于查询缓存的内存用完了，需要将某些缓存逐出，或者由于表被修改导致缓存失效了。

若服务器中有大量缓存未命中，但实际上绝大多数查询都被缓存了，可能是：

- 查询缓存还没有完成预热，mysql还没有机会将查询语句全都缓存起来；
- 查询语句之前从未执行过。
- 缓存失效操作太多了。（缓存碎片，内存不足，数据修改都会造成缓存失效）



## 复制

复制解决的基本问题是让一台服务器的数据与其他服务器保持同步。一同主库的数据可以同步到多台备库上，备库本身也可以被配置乘另外一台服务器的主库。

两种复制方式：**基于行的复制**和**基于语句的复制**。

因为mysql复制大部分时向后兼容的，新版本的服务器可以作为老版本服务器的备库，但不能反过来，因为老版本的服务器可能无法解析新版本所使用的新的特性或语法。

### 复制解决的问题

数据分布：将数据分布在不同的地理位置。

负载均衡：将读操作分布到多个服务器上，实现对密集型应用的优化。

备份：复制对于备份是一项有意义的技术补充，但它不是备份也无法替代备份。

高可用性和故障切换：当前服务器出现故障时，可以切换到另一个系统能够显著的减少宕机的时间。

Mysql升级测试



### 如何工作

1. 在主库上把数据更改记录到二进制日志中。
2. 备库将主库上的日志复制到自己的中继日志中。
3. 备库读取中继日志中的事件，将其重放到备库数据之上。



### 复制的问题和解决方案

#### 数据损坏或丢失的错误

大部分问题都是由于非正常关机导致的复制问题都是由于没有把数据及时的地刷到磁盘；

##### 主库意外关闭

可能在崩溃将没有将最后几个二进制日志事件刷新到磁盘中。

解决方案是从指定备库从下一个二进制日志的开头读日志。

##### 备库意外关闭

解决的办法大部分都是忽略那些错误，因为很难去定位之前发生错误的位置。

##### 主库上的二进制日志损毁

除了忽略损坏的位置外别无选择。

##### 备库上的中继日志损坏

重新获取主库中的日志。



## 可扩展性

可扩展性表明了当需要增加资源以执行更多工作时系统能够获得划算的等同提升的能力。

缺乏扩展能力的系统在达到收益递减的转折点后，将无法进一步增长。



### 扩展

#### 向上扩展

购置更新更好的设备

#### 向外扩展

- 按功能拆分
- 数据分片

#### 通过多实例扩展

可以在一台性能强悍的服务器上运行多个服务器实例。

#### 集群扩展

建立一个集群或者网络，自动扩展，动态的增加/移除服务器。

#### 向内扩展

对不需要的数据进行归档和清理。



### 负载均衡

在一个服务器集群中尽可能地平均负载量。通常在服务器前端设置一个负载均衡器，将请求的连接转发到最空闲的可用服务器。

负载均衡的五个常见目的：**可扩展性**，**高效性**，**可用性**，**透明性**，**一致性**。

 负载均衡的算法：随机，轮询，最少连接数，最快响应，哈希，权重。



##  高可用性

宕机时间越少，表明可用性越高。

### 导致宕机的原因

- 运行环境中最普遍的问题是磁盘空间耗尽
- 性能问题中，最普遍的宕机原因是运行很糟糕的SQL，或服务器Bug或是错误的行为导致。
- 复制问题通常由于主从数据不一致导致。

### 如何实现高可用性

提升平均失效时间（两次故障间的正常运行时间）

降低平均恢复时间（从故障中恢复的时间）

为系统建立冗余，并使得系统具备故障转移的能力，这样就可以在发生故障时及时专业到其他服务器继续运行。